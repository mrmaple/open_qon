"""
$Id: blog.ptl,v 1.152 2007/06/21 13:42:55 jimc Exp $
Blog UI
Classes in this file:

BlogUI          handles blog/
BlogItemUI      handles blog/{item_num}/
BlogCommentUI   handles blog/{item_num}/{comment_num}/

"""
__pychecker__ = "no-noeffect unusednames=request"

import sys
from datetime import datetime
from quixote import get_request
from quixote.html import href, nl2br
from quixote.errors import AccessError, TraversalError
from dulcinea.database import unpack_oid, pack_oid
from dulcinea.errors import NotLoggedInError
from dulcinea.ui.util import format_text
import qon.blog
from qon.group import Group
import qon.karma
from qon.util import sort_list, xml_escape, get_oid, html_unescape
from qon.ui import blocks
from qon.base import get_user, get_user_database, get_group_database, get_tagged_item_database

from qon.ui.base import QonBaseUI
import qon.ui.util
import qon.ui.form 
import qon.ui.blog.form
import qon.api
from qon.ui.user import user_profile_tabs
from qon.ui.blocks.util import path_to_obj, format_string
from qon.tags import standardize_tags

from qon.ui import messages
_ = messages.t
def _h(x): return htmltext(_(x))



class BaseBlogUI(QonBaseUI):
    
    _num_recent_items = 100
    _num_summary_items = 5

    _q_exports = ['new', 'high', 'recent', 'my', 'all', 'more', 'rss', 'atom_xml', 'comments_xml', 'watch', 'unwatch']
    
    def __init__(self, request, ihb):
        """Create Blog UI with instance of IHasBlog.
        
        """
        if not ihb:
            raise TraversalError
        
        self.ihb = ihb
        self.blog = self.ihb.get_blog()
        self.atom_url = blocks.util.full_url(blocks.blog.path_to_blog(self.blog) + 'atom.xml')
        if self.blog:
            self.other_header = '''<link rel="service.feed" type="application/atom+xml" href="%s" title="%s" />''' % (
                self.atom_url, xml_escape(self.blog.watchable_name()))
        self._index_in_blog_format = False
        
        blocks.util.set_watchable_item(request, self.blog)

        
    def _q_access(self, request):
        user = get_user()
        
        if self.ihb is None:
            raise TraversalError
        
        if not self.ihb.can_read(user):

            # if requesting rss, provide HTTP BASIC authentication
            url = request.get_url()
            
            if url[url.rfind('/'):] in ['/rss', '/atom.xml']:
            
                # allow access to RSS if anon users can read
                if self.ihb.can_read(None):
                    return
                    
                # if user is not logged in, challenge for password using HTTP Basic Authentication
                user = qon.ui.util.http_basic_auth(request)

        if not self.ihb.can_read(user):
            raise AccessError
            
        if not self.ihb.is_accepted():
            raise AccessError, \
                '<p class="alert">Sorry, this feature is not available until this group is active.</p>'
        return
    
    def _q_lookup(self, request, name):
        try:
            i = int(name)
        except ValueError:
            
            # capture rss
            if 'rss' in self._q_exports:    # DiscussionsNoRSSUI has no rss
                if name.lower() in ['index.xml', 'index.rdf']:
                    return self.rss(request)
            
            for xml in ['atom_xml', 'comments_xml']:
                if xml in self._q_exports:
                    if name.lower() in [xml.replace('_', '.'),]:
                        return getattr(self, xml)(request)
            
            from qon.ui.blocks.wiki import redirector_to_wiki
            return redirector_to_wiki(self.blog.ihb.get_wiki(), name)
        else:
            return BlogItemUI(request, self.blog, i)

        raise TraversalError

    def get_crumb(self):
        raise NotImplementedError
        
    
    def new [html] (self, request):
        title = "Create a new entry"
        user = get_user()
        
        if not user:
            raise AccessError
        
        blocks.util.set_menu_mode(request, 'new')
        
        # determine cost of posting
        if self.blog is user.blog:
            cost = 0
        else:
            cost = self.blog._karma_new_item
        
        if self.blog.can_pay_for_new_item(user) or (not cost):
            h = '''<p><span class="title">Posting to:</span> %s''' % blocks.util.display_name(self.ihb)
            footer_text = ''
            
            if cost:
                # add text to UI referring to cost of posting
                
                h += '''<br />
                <span class="title">Cost:</span> %d point from your feedback bank. Current bank balance: %d.
                ''' % (cost, user.get_karma_bank_balance())

                footer_text = '''<p><span class="alert">NOTE:</span> %d point will be deducted from your feedback
                bank to create a new topic of discussion.</p>''' % cost

            h += '''</p>'''
            footer_text += blocks.util.punctuation_help

            qon.ui.form.manage_form(request, qon.ui.blog.form.NewBlogItemForm,
                page_title=title,
                menu_text='',
                heading_text=h,
                footer_text=footer_text,
                preview_text=_h(messages.preview_text),
                commit_title=title + ": changes saved.",
                commit_text='<p class="info">Your changes have been recorded.</p>',
                access_test=user and self.ihb.can_edit(user) and self.ihb.can_create_item(),
                access_sorry='<p class="alert">Sorry, you don\'t have permission to create a new entry.</p>',
                blog=self.blog,
                user=user)
        else:
            blocks.util.header(request, title)
            '''<h1>%s</h1>''' % title
            '''<p class="alert">Sorry, you don't have enough points in your feedback bank to create a new entry.</p>
            <p>It costs %d point to create a new entry.
            You have %d points in your feedback bank.
            You can earn more points in your feedback bank
            through your activity on the site, such as reading, posting comments or contributing to workspace pages.
            You also earn points quickly whenever you receive positive feedback from other users.</p>
            ''' % (self.blog._karma_new_item, user.get_karma_bank_balance())
            blocks.util.footer()
        
    def _subpage [html] (self, request, title, name, display_method, heading_text=''):
        blocks.util.set_menu_mode(request, name)
        blocks.util.header(request, title)
        heading_text
        display_method()
        blocks.util.footer()

    def high [html] (self, request):

        def _high_score_items [html] ():
            blocks.blog.ihb_high_score_items(
                ihb=self.ihb,
                count=self._num_recent_items)
    
        title = blocks.util.display_name_plain(self.ihb) + ' Highest Rated Discussions'
        return self._subpage(request,
            title=title,
            heading_text='''<h1>Highest Rated Discussions</h1>''',
            name='high',
            display_method=_high_score_items,
            )
    
    def my [html] (self, request):

        if not get_user():
            raise AccessError
    
        def _watched_items [html] ():
            user = get_user()
            items = [item for item in user.get_watch_list().watched_items() \
                if isinstance(item, qon.blog.BlogItem)]
            
            # filter out items that don't belong in this group
            blogs = self.ihb.get_all_blogs()
            to_remove = []
            for i in items:
                for b in blogs:
                    if b.in_items(i):
                        break
                else:
                    to_remove.append(i)
            
            for i in to_remove:
                items.remove(i)
                    
            '''<h1>Items I'm watching</h1>
            <p class="formHelp">Limited to most recent 100 items</p>
            '''
            
            items = sort_list(items, lambda x: x.last_modified())
            blocks.blog.display_items_table(items,
                count=100)
            
            '''<h1>Items I've submitted</h1>
            <p class="formHelp">Limited to most recent 100 items</p>
            '''
    
            blocks.blog.ihb_recent_author_items(
                ihb=self.ihb,
                author=user,
                count=100)
    
        title = 'My ' + blocks.util.display_name_plain(self.ihb) + ' Discussions'
        return self._subpage(request,
            title=title,
            name='my',
            display_method=_watched_items,
            )
    
    def all [html] (self, request):
        title = self.ihb.get_name()
        
        blocks.util.set_menu_mode(request, 'all')
        blocks.util.header(request, title)
        
        blocks.blog.ihb_recent_items(
            ihb=self.ihb,
            count=sys.maxint,
            blog_format=False)
        
        blocks.util.footer()
        
    def recent [html] (self, request):
    
        def _recent_items [html] ():
            blocks.blog.ihb_recent_items(
                ihb=self.ihb,
                count=self._num_recent_items)

        title = blocks.util.display_name_plain(self.ihb) + ' Most Recent Discussions'
        return self._subpage(request,
            title=title,
            heading_text='''<h1>Most Recent Discussions</h1>''',
            name='recent',
            display_method=_recent_items,
            )

    def get_index_template(self):
        """Return template string for _q_index. Subclasses may override."""
        return '''
        <h1>Discussions</h1>
        %(main_discussion)s
        <h3>Top 5</h3>
        %(highest)s
        <div class="portletMore">
        <a href="high">more Highest Rated...</a>
        </div>
        <h3>Most Recent</h3>
        %(recent)s
        <div class="portletMore">
        <a href="recent">more Most Recent...</a>
        </div>
        <h3>Related Groups</h3>
        %(related)s
        '''
    
    def _q_index [html] (self, request):
        title = ' '.join((self.ihb.get_name(), self.get_crumb()))
        
        blocks.util.add_feed_block(request, {'RSS': [('Discussions', self.atom_url)]})

        blocks.util.set_menu_mode(request, './')
        blocks.util.header(request, title, 
            other_header=self.other_header)

        main_discussion = ''
        if isinstance(self.ihb, qon.group.Group) :
            main_item = self.blog.get_main_item()
            if main_item:
                item_link = blocks.blog.format_item_title(main_item)
                main_discussion = """<span class="title">Owner-selected discussion:</span> %s""" % item_link

        def format_items [html] (items):
            for i in items:
                '''<li>%s</li>\n''' % i
        
        recent_html = blocks.blog.ihb_recent_items(
            ihb=self.ihb,
            count=10,
            blog_format=self._index_in_blog_format)
            
        highest_html = format_items([blocks.blog.format_item_title(i) \
            for i in qon.blog.highest_score_items(self.ihb.get_all_blogs(), 5)])
            
        highest_html = blocks.blog.ihb_high_score_items(
            ihb=self.ihb,
            count=5,
            two_line=False,
            )
                    
        related_html = self._related_groups(request)
        
        htmltext(self.get_index_template() % {
            'main_discussion' : main_discussion,
            'highest': highest_html,
            'recent': recent_html,
            'related': related_html
            }
            )

        blocks.util.footer()
        
    def _related_groups [html] (self, request):
        from qon.group import Group
        
        related = []
        
        if isinstance(self.ihb, Group):
            member_of = get_group_database().member_groups(self.ihb)
            if member_of:
                for g in member_of:
                    if g.can_read(get_user()):
                        related.append('''<h4>%s</h4>''' % blocks.util.display_name(g, karma=0))
                        
                        related.append(blocks.blog.ihb_recent_items(
                            ihb=g,
                            count=5,
                            two_line=False,
                            ))
                                                
                        related.append(
                            '''
                            <div class="portletMore">%s</div>
                            ''' % href(blocks.blog.path_to_blog(g.blog), 'more %s topics...' %
                                blocks.util.display_name_plain(g))
                        )
        return ''.join(related)
        
    def rss(self, request):
        request.response.set_header('content-type', 'application/rdf+xml; charset=utf-8')
        from qon.RSS import CollectionChannel, ns
        
        def embed_cdata(s):
            return str('''<![CDATA[%s]]>'''% s)
        
        title = self.blog.watchable_name()
        link = blocks.util.full_url(blocks.blog.path_to_blog(self.blog))
        description = self.blog.watchable_name()
        
        channel = CollectionChannel()
        
        channel.setMD((ns.rss10, 'channel'), {
            (ns.rss10, 'title'): title,
            (ns.rss10, 'link'): link,
            (ns.rss10, 'description'): description,
            (ns.dc, 'language'): 'en-us',
            (ns.dc, 'date'): (blocks.util.format_datetime_local_iso(self.blog.watchable_last_change())),
            (ns.dc, 'publisher'): messages.publisher,
            (ns.dc, 'creator'): 'Multiple Authors',
            (ns.dc, 'rights'): messages.copyright_notice,
            })
                 
        recent = self.blog.recent_items(count=10, consider_comments=False)
        recent.reverse() # not sure why I have to reverse this for addItem
        for i in recent:
            item = {
                (ns.rss10, 'title'): i.title,
                (ns.rss10, 'link'): blocks.util.full_url(blocks.blog.path_to_item(i)),
                (ns.rss10, 'description'): xml_escape(blocks.util.format_string(i.get_summary(), 256)),
                (ns.content, 'encoded'): embed_cdata(str(i.get_cached_html())),
                (ns.dc, 'date'): (blocks.util.format_datetime_local_iso(i.modified or i.date)),
                }
            channel.addItem(item)
            
        # output rdf
        return str(channel)
        
    def atom_xml(self, request):
        request.response.set_header('content-type', 'text/xml; charset=utf-8')
        feed = blocks.blog.format_atom_blog_feed(self.blog)
        
        recent = self.blog.recent_items(count=10, consider_comments=False)
        for i in recent:
            entry = blocks.blog.format_atom_item(i)
            feed.entries.append(entry)
        
        return feed.output()

    def comments_xml(self, request):
        """Produce ATOM feed of recent discussion comments.
        
        Provides most recent 25 comments on most recent 10 discussions.
        """
        request.response.set_header('content-type', 'text/xml; charset=utf-8')
        feed = blocks.blog.format_atom_blog_feed(self.blog)
        
        recent = self.blog.recent_items(count=10, consider_comments=True)
        for i in recent:
            index = 1
            for c in i.get_all_comments()[-25:]:
                entry = blocks.blog.format_atom_comment(c, i, index)
                feed.entries.append(entry)
                index += 1

        return feed.output()
    
    def watch(self, request):
        return qon.ui.util.watch(request, self.blog)
        
    def unwatch(self, request):
        return qon.ui.util.unwatch(request, self.blog)
            
class DiscussionsUI(BaseBlogUI):
    """Provides UI for Group Discussions."""
    
    def __init__(self, request, ihb):
        BaseBlogUI.__init__(self, request, ihb)

        blocks.util.set_global_mode(request, 'Groups')
        
        # NOTE: self.ihb can be a User, Group or a WikiPage
        from qon.wiki import WikiPage
        if isinstance(self.ihb, WikiPage):
            blocks.util.set_group_mode(request, self.ihb.wiki.group, 'Workspace')
        else:
            blocks.util.set_group_mode(request, self.ihb, 'Discussions')

        menus = [
            {
                'name': 'New topic',
                'path': 'new',
                'title': 'Start a new topic of discussion',
                'disabled': not self.ihb.can_edit(get_user()),
            },
            {
                'name': 'Overview',
                'path': './',
                'title': 'Overview of topics of discussion',
            },
            {
                'name': 'Most recent',
                'path': 'recent',
                'title': 'See most recent items posted or commented upon in reverse chronological order',
            },
            {
                'name': 'My items',
                'path': 'my',
                'title': 'See items you created or are watching',
                'disabled': get_user() is None,
            },
            {
                'name': 'Highest rated',
                'path': 'high',
                'title': 'See items with highest feedback scores',
            },
            ]


        blocks.util.set_menus(request, menus)
        blocks.util.set_help_block(request, 'Discussions')
        
    def get_crumb(self):
        return 'Discussions'


class BlogUI(BaseBlogUI):
    """Provides UI for Users' Personal News (blogs)."""
    
    def __init__(self, request, ihb):
        BaseBlogUI.__init__(self, request, ihb)
        self._index_in_blog_format = True

        blocks.util.set_global_mode(request, 'People')
        request.qon_blog_user = self.ihb
        blocks.util.set_section_tabs(request, user_profile_tabs)
        blocks.util.set_section_mode(request, 'News')
        menus = [
            {
                'name': 'New entry',
                'path': 'new',
                'title': 'Create a new personal news entry',
                'disabled': not self.ihb.can_edit(get_user()),
            },
            {
                'name': 'Overview',
                'path': './',
                'title': 'Overview of topics of discussion',
            },
            {
                'name': 'Recent items',
                'path': 'recent',
                'title': 'See most recent items posted in reverse chronological order',
            },
            {
                'name': 'All items',
                'path': 'all',
                'title': 'See all items posted in reverse chronological order',
            },
            ]

        blocks.util.set_menus(request, menus)
        blocks.util.set_help_block(request, 'News')       

    def get_crumb(self):
        return 'Personal News'
        
    def get_index_template(self):
        """Return template string for _q_index."""
        return '''
        <h1>Personal news</h1>
        %(recent)s
        <div class="portletMore">
        <a href="recent">more Personal News...</a>
        </div>
        '''

    def recent [html] (self, request):
    
        def _recent_items [html] ():
            blocks.blog.ihb_recent_items(
                ihb=self.ihb,
                count=self._num_recent_items)

        title = blocks.util.display_name_plain(self.ihb) + ' Most Recent Personal News'
        return self._subpage(request,
            title=title,
            heading_text='''<h1>Most Recent Personal News</h1>''',
            name='recent',
            display_method=_recent_items,
            )    


class BlogItemUI(QonBaseUI):

    _q_exports = ['edit', 'reply', '_f_p', '_f_n', '_tag', 'set_main', 'unset_main',
        'delete', 'feedbacklist', 'watch', 'unwatch', 'text', 'textfull', 'atom_xml', 'email']
    
    def __init__(self, request, blog, index):
        self.blog = blog
        self.index = index
        self.item = blog.get_item(index)
        self.path = blocks.blog.path_to_blog(self.blog) + str(self.index) + '/'
        self.atom_url = blocks.util.full_url(blocks.blog.path_to_item(self.item)) + 'atom.xml'

        if self.item:
            self.other_header = '''<link rel="service.feed" type="application/atom+xml" href="%s" title="%s" />''' % (
                self.atom_url, xml_escape(self.item.watchable_name()))
        
        user = get_user()
        if user and self.item:
            self.last_read = self.item.last_read(user)
        else:
            self.last_read = None
        
        if self.item is None:
            raise TraversalError

        # mark this BlogItem as seen at the current time by the current user
        # (records the current time into the user's watchlist (only if it's
        #  being actively watched by the user)
        blocks.util.set_watchable_item(request, self.item)
        
        menus = [
            {
                'name': 'View',
                'items': [
                    {
                        'name': 'Only Rated Comments',
                        'path': '?min_score=1',
                        'title': 'Only display comments that have received at least 1 feedback point.',
                    },
                    {
                        'name': 'Plain Text',
                        'path': 'text',
                        'title': 'View discussion (without comments) in plain text format.',
                    }, 
                    {
                        'name': 'Plain Text With Comments',
                        'path': 'textfull',
                        'title': 'View discussion and all its comments in plain text format.',
                    },
                    ],
            },
            {
                'name': 'Reply',
                'path': 'reply',
                'title': 'Quote the text of this item in a new comment.',
                'disabled': not get_user() or not self.item.get_summary() or self.item.is_deleted(),
                # XXX hack alert: suppress reply menu for empty BlogItems, which contain
                # workspace page comments
            },
            {
                'name': 'Edit',
                'path': 'edit',
                'title': 'Make changes to this item.',
                'disabled': not self.item.can_edit(get_user()) or self.item.is_deleted(),
            },
            {
                'name': 'Delete',
                'path': 'delete',
                'title': 'Delete this item.',
                'disabled': not self.item.can_delete(get_user()) or self.item.is_deleted(),
            },
            ]

        blocks.util.set_menus(request, menus)
        blocks.util.set_help_block(request, 'Discussion Item')

        # karma
        if user is not self.item.author:
            #self.item.author.karma_activity_credit_sampled()
            user.karma_activity_credit_sampled()

    def _q_lookup(self, request, index):
        try:
            i = int(index)
        except ValueError:

            if 'atom_xml' in self._q_exports:
                if index.lower() in ['atom.xml']:
                    return self.atom_xml(request)

            from qon.ui.blocks.wiki import redirector_to_wiki
            return redirector_to_wiki(self.blog.ihb.get_wiki(), index)
        else:
            return BlogCommentUI(request, self.blog, self.item, i)
        
    def _q_access(self, request):
        if self.item is None:
            raise TraversalError
            
    def _check_deleted(self):
        if self.item.is_deleted():
            raise AccessError, '<p class="alert">Sorry, this item has been deleted.</p>'

    def _deleted_item [html] (self, request):

        deleted_note = self.item.get_deleted_note()

        blocks.util.header(request, self.item.title, other_header=self.other_header)
        self._format_item_info()
        if deleted_note:
            blocks.wiki.rst_to_html(deleted_note)
        else:
            '''
            <p><em>This topic has been deleted.</em></p>
            '''
        blocks.util.footer()

    def _q_index [html] (self, request):
        title = self.item.title
        user = get_user()

        if self.item.is_deleted():
            return self._deleted_item(request)
        
        blocks.util.add_feed_block(request, {'RSS': [('Comments', self.atom_url)]})

        # get item's comments and store them to avoid re-fetching
        self.item_comments = self.item.get_all_comments()
        
        force_show = request.get_form_var('show')
        min_score = request.get_form_var('min_score') or blocks.blog._default_min_score
        try:
            min_score = int(min_score)
        except ValueError:
            min_score = blocks.blog._default_min_score
        
        # FIXME user should be able to post a comment to his own personal news
        
        # see if an anon user is trying to force view
        if not self.item.can_show() and force_show and not user:
            raise NotLoggedInError, '<p class="alert">Sorry, you must be signed in to view a folded item.</p>'
        
        if force_show or self.item.can_show():

            # cookie this page
            blocks.util.cookie_this_page(self.item)
        
            # declare this as emailable
            blocks.util.set_emailable_item(request, self.item)
            
            # user must be signed in to view suppressed item
            
            if (not user and self.blog.ihb.can_read(None)) or (not user.can_post()):
                # anon user can read but can't comment; or non-anon user who can't post
                blocks.util.header(request, title, other_header=self.other_header)
                '''<h1>%s</h1>''' % title
                self._format_item_info()
                self._format_item_content(min_score=min_score)
                #'''Sign up or log in to comment.'''
                '''<A HREF="#top" class="alert">Sign in or Join now to add your own comment.</A>'''
                blocks.util.footer()
            else:
                # normal display. we could be paginated, or all on one page.
                # we could display the comment form, or not. if we're all
                # on one page, we display the comment form.
                
                display_comment_form = False
                paginate_display = False
                
                if request.get_method() == 'POST':
                    display_comment_form = True
                    
                    # we 'display' the form to process the post, but no need
                    # to generate actual content
                    heading_text = ''
                    
                elif min_score == blocks.blog._default_min_score:
                    # no comment filtering
                    paginate_display = True
                    num_pages = self._get_num_pages(self.item_comments)
                    page, start = qon.ui.util.get_page_start(blocks.blog.comments_per_page, request)

                    # display comments form only on last page
                    if (page == num_pages):
                        display_comment_form = True
                
                    # generate content, to be displayed with or without the comment form
                    heading_text=''.join((
                        self._format_item_info(cur_page_num=page),
                        self._format_item_content(min_score=min_score, paginate=paginate_display, notice_read=not display_comment_form)))
                    
                    # user is considered to have read entire item if he is on the last page
                    # if we didn't do this here, items may appear unread even if the last page
                    # had been viewed, due to tiny difference in blog item's update time
                    # versus the creation time of the last comment
                    if display_comment_form:
                        self.item.read_item(user)
                
                else:
                    # comment filtering: no pagination
                    display_comment_form = True
                    
                    # generate content with feedback threshold form
                        
                    heading_text=''.join((
                        self._format_item_info(cur_page_num=-1),
                        self._format_item_content(
                            min_score=min_score,
                            paginate=paginate_display,
                            show_feedback_thresh=True)))
                            
                    # user is considered to have read entire item now
                    self.item.read_item(user)
                
                # now generate the output
                
                if display_comment_form:
            
                    qon.ui.form.manage_form(request, qon.ui.blog.form.CommentItemForm,
                        page_title=title,
                        heading_text=heading_text, 
                        other_header=self.other_header,
                        footer_text=blocks.util.punctuation_help,
                        preview_text=_h(messages.preview_text),
                        commit_title="Comment saved.",
                        commit_text='<p class="info">Your changes have been recorded.</p>',
                        access_test=_can_comment(user),
                        access_sorry='<p class="alert">Sorry, you don\'t have permission to make a comment.</p><p>Maybe you need to sign in?</p>',
                        blog=self.blog,
                        item=self.item,
                        user=user)
                else:
                    blocks.util.header(request, title, other_header=self.other_header)
                    '''<h1>%s</h1>''' % title
                    heading_text
                    blocks.util.footer()
        else:
            # karma too low to show
            blocks.util.header(request, title, other_header=self.other_header)
            blocks.blog.cant_show_item(self.item, './?show=1')
            blocks.util.footer()
        
    def _format_item_info [html] (self, cur_page_num=0):
        '<p class="subtitle">'
        blocks.blog.format_item_stats(self.item, karma=1, full_dates=1, indent=0, last_read=self.last_read, cur_page_num=cur_page_num)
        '</p>'
    
    def _get_num_pages(self, comments):
        if not comments:
            return 1
        num_entries = len(comments)
        num_pages = (num_entries - 1) / blocks.blog.comments_per_page + 1
        return num_pages
    
    def _format_item_content [html] (self,
        no_comments=0,
        min_score=blocks.blog._default_min_score,
        paginate=True,
        show_feedback_thresh=False,
        notice_read=True):
        
        def topic_content [html] ():
            if not self.item.is_deleted():
                htmltext(self.item.get_cached_html())
                '<br />'

                if self.item.get_summary() and _can_comment(get_user()):
                    # XXX hack alert: testing for empty summary suppresses the reply... tag on
                    # workspace page comments, since there is a dummy BlogItem to contain all
                    # the comments.

                    # Tagging a whole discussion
                    taggable_group = isinstance(self.blog.ihb, Group) and qon.tags.group_can_tag(self.blog.ihb.get_user_id())
                    taggable_user_news = type(self.blog.ihb) is qon.user.User

                    #if taggable_group or taggable_user_news:
                    if taggable_group or taggable_user_news:
                        qon.ui.blocks.tags.edit_and_current(self.item)
                        """<div class="formHelp">Tags will be listed as suggestions for each comment</div>"""


                    #if isinstance(self.blog.ihb, Group) and qon.tags.group_can_tag(self.blog.ihb.get_user_id()):
                    #    qon.ui.blocks.tags.edit_and_current(self.item)
                    #    """<div class="formHelp">All discussion tags will be listed as suggestions for each comment</div>"""

                    '''
                    <div class="portletMore"><a href="reply">quote and reply...</a></div>
                    '''
        
        def page_control [html] ():
            if num_pages > 1:
                format_str = ('''<a href="./?min_score=%d&show=1''' % min_score) + '''&page=%s">'''
                '''<h2>Comments %spage %s</h2><br /><br />''' % (
                    blocks.util.get_pagenav(page, num_pages, format_str),
                    page)
        
        if not self.item.is_deleted():
                
            comments = self.item_comments
            page = 1

            if not no_comments and comments:
                
                if paginate:
                    page, start = qon.ui.util.get_page_start(blocks.blog.comments_per_page)
                    
                    num_entries = len(comments)
                    num_pages = (num_entries - 1) / blocks.blog.comments_per_page + 1
                    comments = comments[start:start+blocks.blog.comments_per_page]
                else:
                    # if we're filtering on feedback score, don't paginate
                    page = num_pages = 1
                
            if page == 1:
                # display topic content on page 1 only
                topic_content()
                
                '''
                <hr noshade="noshade" />
                '''
                
                if show_feedback_thresh:
                    '''
                    <div style="text-align: right;"><form>Comment feedback threshold: <input type="text" name="min_score" size="2" value="%d" />
                    <input type="submit" value="Set" /></form></div>
                    ''' % min_score
                
            if not no_comments and comments:
                page_control()
                blocks.blog.item_comments(comments, self.item, last_read=self.last_read, min_score=min_score)
                page_control()
                
                # set user's last_read time to the timestamp of the last comment displayed on this page
                if notice_read:
                    self.item.read_item(get_user(), comments[-1].last_modified())

        else:
            '<p class="alert">This item has been deleted.</p>'
        
    def edit [html] (self, request):
        self._check_deleted()
        blocks.util.set_menu_mode(request, 'edit')
        title="Edit an entry"
        
        user = get_user()
        
        # author or manager can delete item
        access_test = self.item.can_edit(user)
        
        qon.ui.form.manage_form(request, qon.ui.blog.form.EditBlogItemForm,
            page_title=title,
            preview_text=_h(messages.preview_text),
            footer_text=blocks.util.punctuation_help,
            commit_title=title + ": changes saved.",
            commit_text='<p class="info">Your changes have been recorded.</p>',
            access_test=access_test,
            access_sorry='<p class="alert">Sorry, you don\'t have permission to edit this entry.</p>',
            blog=self.blog,
            item=self.item)
    
    def reply [html] (self, request):
        self._check_deleted()
        blocks.util.set_menu_mode(request, 'reply')
        title = "Reply to %s" % blocks.util.format_string(self.item.title)
        user = get_user()
                
        qon.ui.form.manage_form(request, qon.ui.blog.form.CommentItemForm,
            page_title=title,
            footer_text=blocks.util.punctuation_help,
            preview_text=_h(messages.preview_text),
            commit_title="Comment saved.",
            commit_text='<p class="info">Your changes have been recorded.</p>',
            access_test=_can_comment(user),
            access_sorry='<p class="alert">Sorry, you don\'t have permission to make a comment.</p><p>Maybe you need to sign in?</p>',
            blog=self.blog,
            item=self.item,
            default_text=_make_quotation_string(self.item.author, self.item.get_summary()),
            user=user)

    def get_crumb(self):
        if self.item is not None:
            return blocks.util.format_string(self.item.title)
        return ''

    def delete [html] (self, request):
        self._check_deleted()

        title = 'Deleting item: %s' % blocks.util.format_string(self.item.title)

        user = get_user()        
        blocks.util.set_menu_mode(request, 'delete')
        
        # get default delete permission        
        access_test = self.blog.ihb.can_delete_item(self.item)

        # author or manager can delete item
        access_test = access_test and self.item.can_delete(user)
        
        qon.ui.form.manage_form(request, qon.ui.blog.form.DeleteItemForm,
            page_title=title,
            heading_text='<p class="alert">Are you sure you want to delete this item?</p>',
            commit_text='<p class="info">The item has been deleted.</p>',
            access_test=access_test,
            access_sorry='<p class="alert">Sorry, you don\'t have permission to delete this item.</p>',
            item=self.item)
        
    def text [plain] (self, request):
        self._check_deleted()
        request.response.set_content_type('text/plain')
        blocks.blog.format_plain_item_header(self.item)
        self.item.get_summary()
        '\n'
        self.item.get_main()

    def textfull [plain] (self, request):
        self._check_deleted()
        request.response.set_content_type('text/plain')
        blocks.blog.format_plain_item_header(self.item)
        self.item.get_summary()
        '\n'
        self.item.get_main()
        
        comments = self.item.get_all_comments()
        if comments:
            '''\n\n----\n\n**Comments**\n\n'''
            for c in comments:
                blocks.blog.format_plain_item_header(c, show_title=0)
                c.get_summary()
                '\n\n----\n\n'
    
    def feedbacklist [html] (self, request):
        do_feedbacklist(request, self.item)
        
    def _f_p (self, request):
        user = get_user()
        if not user:
            raise AccessError
        self._check_deleted()
        qon.api.karma_give_good(user, self.item)
        return request.redirect('./?e=fp')
        
    def _f_n (self, request):
        user = get_user()
        if not user:
            raise AccessError
        self._check_deleted()
        qon.api.karma_give_bad(user, self.item)
        return request.redirect('./?e=fn')

    def _tag [plain] (self, request):
        user = get_user()
        group = None
        if isinstance(self.blog.ihb, Group):
            group = self.blog.ihb

        item_oid_text = request.get_form_var('item_oid')
        item_oid = pack_oid(long(item_oid_text))
        tags_line = request.get_form_var('tags')

        #"tagging %s with %s" % (item_oid_text, tags)
        # none becomes the comment when we add comments to the UI.
        qon.api.tag_item(tags_line, user, item_oid, group, None)

        # because the tagged item may be either the entire discussion
        # or an individual comment, we have to retrieve the actual object
        # just to index it.
        item = get_oid(item_oid)

        # make sure this blog is re-indexed
        if item.title == 'comment' or item.not_watchable:   # XXX hack to find comment
            assert(item.parent_blogitem)
            qon.search.searchengine.notify_edited_blog_comment(item)
        else:
            # handle edited blog entries
            qon.search.searchengine.notify_edited_blog_item(item)
        #

        format = request.get_form_var('format')
        if format and format == 'json':
            result_tags = " ".join(qon.tags.standardize_tags(tags_line))
            """{ "result" : "success",
            "newtags": "%s",
            "item_oid" : "%s"
            }""" % (result_tags, item_oid_text)
        else:
            comment = get_oid(item_oid)
            #self.item.parent_blogitem = self.blog
            #path_in_discussion = "%s?%s" % (self.path, qon.ui.blocks.blog.comment_anchor(self.item))
            if comment.parent_blogitem:
                path = qon.ui.blocks.blog.path_to_comment_in_item(self.item, comment)
            else:
                path = blocks.blog.path_to_item(self.item)
            return request.redirect(path)
        #
    #

    def set_main (self, request):
        user = get_user()
        if not user and not self.blog.ihb.is_owner(user):
            raise AccessError
        self.blog.set_main_item(self.item)
        return request.redirect('.')

    def unset_main (self, request):
        user = get_user()
        if not user and not self.blog.ihb.is_owner(user):
            raise AccessError
        blog = None
        self.blog.set_main_item(None)
        return request.redirect('.')

    def atom_xml(self, request):
        self._check_deleted()
        request.response.set_header('content-type', 'text/xml; charset=utf-8')
        
        # Create a Feed for this item
        feed = blocks.blog.format_atom_item_feed(self.item)
        
        # Add the first entry, which is the item itself
        entry = blocks.blog.format_atom_item(self.item)
        feed.entries.append(entry)
        
        # now do the comments
        index = 1
        for comment in self.item.get_all_comments():
            entry = blocks.blog.format_atom_comment(comment, self.item, index)
            feed.entries.append(entry)
            index += 1
    
        return feed.output()
        
    def watch(self, request):
        self._check_deleted()
        return qon.ui.util.watch(request, self.item)
        
    def unwatch(self, request):
        return qon.ui.util.unwatch(request, self.item)

    def email [html] (self, request):
        return blocks.action.email_this_page(request, self.item)
        

class BlogCommentUI(QonBaseUI):

    _q_exports = ['_tag', 'edit', 'reply', 'delete', 'text', 'history', 'feedbacklist', '_f_p', '_f_n', 'atom_xml', 'email']
    
    def __init__(self, request, blog, item, comment_index):
        self.blog = blog
        self.item = item
        self.comment = item.get_comment(comment_index)
        self.path = blocks.blog.path_to_blog(self.blog) + str(blog.item_index(item)) + '/' + \
            str(comment_index) + '/'
        
        if self.comment is None:
            raise TraversalError
        
        self.other_header = '''<link rel="service.feed" type="application/atom+xml" href="%s" title="%s" />''' % (
            blocks.util.full_url(blocks.blog.path_to_comment(self.item, self.comment)) + 'atom.xml',
            'Comment on '+xml_escape(self.item.watchable_name()))

        # comments are not watchable
        blocks.util.set_watchable_item(request, None)
                
        if self.comment.author is not get_user():
            #self.comment.author.karma_activity_credit_sampled()
            get_user().karma_activity_credit_sampled()
        
        cur_user = get_user()
        
        menus = [
            {
                'name': 'View',
                'items': [
                    {
                        'name': 'Plain Text',
                        'path': 'text',
                        'title': 'View comment in plain text format.',
                    },
                    {
                        'name': 'History of edits',
                        'path': 'history',
                        'title': 'View original text, and all edits since.',
                    },
                    ],
            },
            {
                'name': 'Reply',
                'path': 'reply',
                'title': 'Quote the text of this item in a new comment.',
                'disabled': not cur_user or self.comment.is_deleted() or self.item.is_deleted(),
            },
            {
                'name': 'Edit',
                'path': 'edit',
                'title': 'Make changes to this item',
                'disabled': not self.comment.can_edit(cur_user) or self.comment.is_deleted(),
            },
            {
                'name': 'Delete',
                'path': 'delete',
                'title': 'Delete this item',
                'disabled': not self.comment.can_delete(cur_user) or self.comment.is_deleted(),
            },
            ]

        blocks.util.set_menus(request, menus)
        blocks.util.set_help_block(request, 'Discussion Item')

    def _q_access(self, request):
        if self.comment is None:
            raise TraversalError
            
        if not self.comment.can_show() and not get_user():
            raise NotLoggedInError, '<p class="alert">Sorry, you must be signed in to view a folded comment.</p>'

    def _q_lookup(self, request, name):
        if 'atom_xml' in self._q_exports:
            if name.lower() in ['atom.xml']:
                return self.atom_xml(request)
        
        raise TraversalError

    def _check_parent_deleted(self):
        if self.item.is_deleted():
            raise AccessError, '<p class="alert">Sorry, the discussion containing this comment has been deleted.</p>'

    def _check_comment_deleted(self):
        if self.comment.is_deleted():
            raise AccessError, '<p class="alert">Sorry, this comment has been deleted.</p>'

    def _deleted_item [html] (self, request):

        deleted_note = self.comment.get_deleted_note()

        blocks.util.header(request, self.item.title, other_header=self.other_header)
        self._format_item_info()
        if deleted_note:
            blocks.wiki.rst_to_html(deleted_note)
        else:
            '''
            <p><em>This topic has been deleted.</em></p>
            '''
        blocks.util.footer()
    def _q_index [html] (self, request):
        # cookie this page
        blocks.util.cookie_this_page(self.comment)
        
        # declare this as emailable
        blocks.util.set_emailable_item(request, self.comment)
        
        title = 'Comment by %s' % blocks.util.display_name_plain(self.comment.author)
        comment_is_deleted = self.comment.is_deleted()

        blocks.util.header(request, title, other_header=self.other_header)
        '<h2>%s</h2>' % title
        '<p class="subtitle">'
        blocks.user.author(self.comment)
        '<br />'
        blocks.user.date(self.comment)
        if self.comment.modified:       # added Edited line (Alex 2005-03-29)
            '<br /><span class="alert">'
            _('Edited:')
            '</span> %s' % qon.ui.blocks.util.format_datetime(self.comment.modified)        
        '<br />'
        '<span class="title">Comment on: </span>'
        blocks.blog.format_item_title(self.item, comment=self.comment)  # scroll to comment in context (Alex 2004-09-01)
        '<br />'

        blocks.user.karma(self.comment, self.path,
            show_control=not comment_is_deleted,
            show_stars=1,
            show_feedbacklist=1)  # MUST pass path for comments
        '</p>'

        if comment_is_deleted:
            deleted_note = self.comment.get_deleted_note()
            if deleted_note:
                blocks.wiki.rst_to_html(deleted_note)
            else:
                '''
                <p><em>This comment has been deleted.</em></p>
                '''
        else:
            htmltext(self.comment.get_cached_html())

            taggable_group = isinstance(self.blog.ihb, Group) and qon.tags.group_can_tag(self.blog.ihb.get_user_id())
            taggable_user_news = type(self.blog.ihb) is qon.user.User
            #if taggable_group or taggable_user_news:
            if taggable_group:
                qon.ui.blocks.tags.edit_and_current(self.comment)
            
        blocks.util.footer()

    def _tag [plain] (self, request):
        user = get_user()
        group = None #self.blog.group
        if isinstance(self.blog.ihb, qon.group.Group) :
            group = self.blog.ihb

        item_oid_text = request.get_form_var('item_oid')
        item_oid = pack_oid(long(item_oid_text))
        tags_line = request.get_form_var('tags')

        #"tagging %s with %s" % (item_oid_text, tags)
        # none becomes the comment when we add comments to the UI.
        qon.api.tag_item(tags_line, user, item_oid, group, None)

        #if self.blog.title == 'comment' or self.blog.not_watchable:   # XXX hack to find comment
        #    assert(self.blog.parent_blogitem)
        print "notifying1 the blog comment edit"

        qon.search.searchengine.notify_edited_blog_comment(self.comment)
        #else:
            # handle edited blog entries
        #    qon.search.searchengine.notify_edited_blog_item(self.comment)

        format = request.get_form_var('format')
        if format and format == 'json':
            result_tags = " ".join(qon.tags.standardize_tags(tags_line))
            """{ "result" : "success",
            "newtags": "%s",
            "item_oid" : "%s"
            }""" % (result_tags, item_oid_text)
        else:
    
            comment = get_oid(item_oid)
            #self.item.parent_blogitem = self.blog
            #path_in_discussion = "%s?%s" % (self.path, qon.ui.blocks.blog.comment_anchor(self.item))
            if comment.parent_blogitem:
                path = qon.ui.blocks.blog.path_to_comment_in_item(self.item, comment)
            else:
                path = blocks.blog.path_to_item(self.item)
            return request.redirect(path)
        #
    #

    def edit [html] (self, request):
        self._check_comment_deleted()
        blocks.util.set_menu_mode(request, 'edit')
        
        title="Edit an entry"
        
        user = get_user()
        
        # author or manager can edit item
        access_test = self.comment.can_edit(user)

        qon.ui.form.manage_form(request, qon.ui.blog.form.EditBlogCommentForm,
            page_title=title,
            preview_text=_h(messages.preview_text),
            footer_text=blocks.util.punctuation_help,
            commit_title=title + ": changes saved.",
            commit_text='<p class="info">Your changes have been recorded.</p>',
            access_test=access_test,
            access_sorry='<p class="alert">Sorry, you don\'t have permission to edit this entry.</p>',
            blog=self.blog,
            item=self.comment)
            
    def reply [html] (self, request):
        self._check_parent_deleted()
        self._check_comment_deleted()
        blocks.util.set_menu_mode(request, 'reply')
        title = "Reply to %s's comment on %s" % (blocks.util.display_name_plain(self.comment.author),
            blocks.util.format_string(self.item.title))
        user = get_user()
                
        qon.ui.form.manage_form(request, qon.ui.blog.form.CommentItemForm,
            page_title=title,
            footer_text=blocks.util.punctuation_help,
            preview_text=_h(messages.preview_text),
            commit_title="Comment saved.",
            commit_text='<p class="info">Your changes have been recorded.</p>',
            access_test=_can_comment(user),
            access_sorry='<p class="alert">Sorry, you don\'t have permission to make a comment.</p><p>Maybe you need to sign in?</p>',
            blog=self.blog,
            item=self.item,
            default_text=_make_quotation_string(self.comment.author, self.comment.get_summary()),
            user=user)
    
    def delete [html] (self, request):
        self._check_comment_deleted()
        blocks.util.set_menu_mode(request, 'delete')

        user = get_user()
        title = 'Deleting comment by: %s' % blocks.util.display_name_plain(self.comment.author)

        qon.ui.form.manage_form(request, qon.ui.blog.form.DeleteItemForm,
            page_title=title,
            heading_text='<p class="alert">Are you sure you want to delete this comment?</p>',
            commit_text='<p class="info">The comment has been deleted.</p>',
            access_test=self.comment.can_delete(user),
            access_sorry='<p class="alert">Sorry, you don\'t have permission to delete this comment.</p>',
            item=self.comment)
            
    def get_crumb(self):
        if self.comment is not None:
            return htmltext('Comment by %s') % blocks.util.display_name_plain(self.comment.author)
        else:
            return ''

    def text [plain] (self, request):
        self._check_comment_deleted()
        request.response.set_content_type('text/plain')
        blocks.blog.format_plain_item_header(self.comment, show_title=0)
        self.comment.get_summary()

    def history [html] (self, request):
        title = 'History of comment by %s' % blocks.util.display_name_plain(self.comment.author)
        blocks.util.header(request, title)
        '<h1>%s</h1>' % title
        '<p class="explanation">Plus signs (+) indicate lines added in most recent version, '
        'while minus signs (-) indicate lines removed in most recent version. '
        '</p>'
        '<hr noshade="noshade" />'

        self._check_comment_deleted()

        if self.comment.history:
            '<pre>'
            self.comment.history
            '</pre>'
        else:
            "This comment has not been edited yet."

    def feedbacklist [html] (self, request):
        do_feedbacklist(request, self.comment, blocks.blog.path_to_comment(self.item, self.comment))
        
    def _f_p (self, request):
        user = get_user()
        if not user:
            raise AccessError
        self._check_comment_deleted()
        qon.api.karma_give_good(user, self.comment)
        return request.redirect('./?e=fp')
        
    def _f_n (self, request):
        user = get_user()
        if not user:
            raise AccessError
        self._check_comment_deleted()
        qon.api.karma_give_bad(user, self.comment)
        return request.redirect('./?e=fn')

    def email [html] (self, request):
        return blocks.action.email_this_page(request, self.comment)
    
    def atom_xml(self, request):
        self._check_comment_deleted()
        request.response.set_header('content-type', 'text/xml; charset=utf-8')

        # create a feed for this comment
        feed = blocks.blog.format_atom_comment_feed(self.comment, self.item)
        
        # add the entry
        entry = blocks.blog.format_atom_comment(self.comment, self.item)
        feed.entries.append(entry)
            
        return feed.output()


# -------------------------------------------------------------------------

def do_feedbacklist [html] (request, item, path_to_item=None):
    # must pass path_to_item for comments - others can pass None

    _rollout_date = datetime(2005, 2, 10, 0)    # utc
    _rollout_date_display = "February 9, 2005, 4:00PM PST"

    assert isinstance(item, qon.karma.HasKarma)

    def make_rows(karma_givers, show_all=False):
        rows = []
        for karma, user_id in karma_givers:
            if abs(karma) >= abs(qon.karma.show_neg_threshold):
                rows.append((blocks.user.display_name(user_db.get_user(user_id)),
                    karma))
            else:
                if show_all:
                    rows.append((blocks.user.display_name(user_db.get_user(user_id)),
                        ' '))
        return rows
    
    def user_tables [html] ():
        # positive feedback
        rows = make_rows(pos_karma_givers, show_all=staff_access)
        blocks.util.format_table_rows(rows, headings=['Significant Positive Feedback From', 'Amount'])
        
        # negative feedback
        rows = make_rows(neg_karma_givers, show_all=staff_access)
        blocks.util.format_table_rows(rows, headings=['Significant Negative Feedback From', 'Amount'])
    

    # don't let anon users like crawlers see this
    if not get_user():
        raise AccessError
    
    staff_access = request.get_form_var('staff')
    if staff_access and get_user().is_staff():
        staff_access = True
    else:
        staff_access = False
        
    user_db = get_user_database()
    
    # get item title
    if hasattr(item, str('author')):
        item_title = "%s by %s" % (item.get_title(), blocks.util.display_name_plain(item.author))
    else:
        item_title = item.get_title()
    
    title = messages.site_title + ': Feedback for %s' % item_title
    blocks.util.header(request, title)
    '''<h1>Feedback for %s</h1>''' % item_title
    '''<p class="formHelp">
    The following users have given more than 5 positive feedback points or more than
    5 negative feedback points to this item. They are listed in decreasing
    order, with the most feedback having been given by the first user(s) listed.
    </p>
    '''
    
    # get all the info
    plus_total, neg_total, pos_karma_givers, neg_karma_givers = item.karma_details()
    

    '''<p class="subtitle">'''
    blocks.user.karma(item, path_to_item, show_stars=1)
    '''<br />
    <span class="title"><span class="info">Positive</span> feedback received:</span> %d users, %d points.<br />
    <span class="title"><span class="alert">Negative</span> feedback received:</span> %d users, %d points.<br />
    <span class="title">Points decayed due to inactivity:</span> %d
    </p>''' % (len(pos_karma_givers), plus_total,
        len(neg_karma_givers), neg_total,
        (plus_total - neg_total) - item.get_karma_score(),
        )
    
    # don't provide this information for items created before rollout date
    # this only applies to BlogItems and comments
    if not hasattr(item, str('date')) or item.date >= _rollout_date:
        user_tables()
    else:
        '''<p class="alert">Sorry, information on specific users' feedback is not
        available for items created before %s.''' % _rollout_date_display

    blocks.util.footer()


def _make_quotation_string(author, text):
    quotation = [_('''%s said:''') % blocks.util.display_name_plain(author), '']
    for l in text.strip().splitlines():
        quotation.append(' '*4 + l)
        #quotation.append(tw.fill(l))
    
    quotation.extend(['', ''])
    
    return '\n'.join(quotation)


def _can_comment(user):
    return user is not None and user.can_post()
