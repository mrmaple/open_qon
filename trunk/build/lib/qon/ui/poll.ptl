"""
$Id: poll.ptl,v 1.25 2007/01/06 01:41:38 jimc Exp $
"""
__pychecker__ = "no-noeffect unusednames=request"

# enable rollout test code
_ROLLOUT_TEST = False

from datetime import datetime, timedelta
from quixote import get_user, get_request
from quixote.errors import AccessError, TraversalError
from quixote.html import href
from qon.base import get_user_database
from qon.ui.base import QonBaseUI
from qon.ui import blocks
from qon.ui.form import QonForm, manage_form, make_widget_read_only
from qon import api
import qon.ui.util
import qon.util

from qon.ui import messages
_ = messages.t
def _h(x): return htmltext(_(x))

class PollUI(QonBaseUI):
    _q_exports = ['new', 'new_simple', 'new_custom', 'completed', 'watch', 'unwatch']
    
    def __init__(self, request, ihb):
        if not ihb:
            raise TraversalError
        
        self.ihb = ihb
        self.polls = ihb.polls
        
        blocks.util.set_watchable_item(request, self.polls)
        
        blocks.util.set_global_mode(request, 'Groups')
        blocks.util.set_group_mode(request, self.ihb, 'Polls')
        menus = [
            {
                'name': 'New poll',
                'path': 'new',
                'title': 'Create a new poll.',
                'disabled': not self.ihb.can_edit(get_user()),
            },
            {
                'name': 'Active polls',
                'path': './',
                'title': 'View active polls.',
            },
            {
                'name': 'Completed polls',
                'path': 'completed',
                'title': 'View completed polls.',
            },
            ]
        blocks.util.set_menus(request, menus)
        blocks.util.set_help_block(request, 'Polls')
    
    def _q_access(self, request):
        user = get_user()
        
        if _ROLLOUT_TEST:
            if self.ihb.get_user_id() != 'funstuff':
                raise AccessError, \
                '''<p class="alert">This new feature is currently being tested before a wide release. To see it in action,
                visit the <a href="/group/funstuff/poll/">Fun Stuff</a> group.</p>
                '''
        
        if self.ihb is None:
            raise TraversalError
        
        if not self.ihb.can_read(user):
            raise AccessError
            
        if not self.ihb.is_accepted():
            raise AccessError, \
                '<p class="alert">Sorry, this feature is not available until this group is active.</p>'
    
    def get_crumb(self):
        return "Polls"
    
    def _q_lookup(self, request, name):
        try:
            i = int(name)
        except ValueError:
            raise TraversalError
        
        return PollItemUI(request, self.polls, i)
    
    def _q_index [html] (self, request):
        blocks.util.set_menu_mode(request, './')
        title = 'ned.com: %s Active Polls' % blocks.util.display_name_plain(self.ihb)
        blocks.util.header(request, title)
        '''<h1>Active Polls</h1>
        <p class="formHelp">
        These are the polls currently being conducted in this group, sorted by the polls
        ending first. Polls you have not voted in appear in bold.
        </p>
        '''
        
        polls = [poll for date, poll in self.polls.active_polls()]
        if polls:
            now = datetime.utcnow()
            rows = []
            for poll in polls:
                rows.append(format_poll_row(poll, now=now))
            blocks.util.format_table_rows(rows, ['Poll', 'Votes Cast', 'Ending'],
                table_class="forum-listing")
        else:
            '''
            <p>There are no polls currently active.</p>
            '''
        
        blocks.util.footer()

    def completed [html] (self, request):
        blocks.util.set_menu_mode(request, 'completed')
        title = 'ned.com: %s Completed Polls' % blocks.util.display_name_plain(self.ihb)
        blocks.util.header(request, title)
        '''<h1>Completed Polls</h1>
        <p class="formHelp">
        These polls have concluded, and they are sorted by the polls which have ended most recently. Click the title to see your vote, or the results link to see results.
        Polls you have not voted in appear in bold, but it's too late to vote!
        </p>
        '''
        
        polls = [poll for date, poll in self.polls.completed_polls()]
        if polls:
            now = datetime.utcnow()
            rows = []
            for poll in polls:
                rows.append(format_poll_row(poll, now=now, with_results=True))
            blocks.util.format_table_rows(rows, ['Poll', 'Votes Cast', 'Ended'],
                table_class="forum-listing")
        else:
            '''
            <p>There are no completed polls.</p>
            '''
        blocks.util.footer()
        
    def new [html] (self, request):
        blocks.util.set_menu_mode(request, 'new')
        title = 'Create a New Poll'
        blocks.util.header(request, title)

        # reset multi-page form session
        NewCustomPollForm().clear_session()
        
        '''<h1>%s</h1>''' % title
        '''
        <h2>Choose a type of Poll:</h2>
        
        <p>
        <span class="title"><a href="new_simple">Simple Poll</a></span><br />
        A simple poll in which voters anonymously choose between one of two options
        (yes or no, a or b).
        </p>
        
        <p>
        <span class="title"><a href="new_custom">Custom Poll</a></span><br />
        A poll which allows you to select from a number of advanced options,
        including who can vote, how many choices,
        who can see the results, whether the votes are anonymous, etc.
        </p>
        '''
        
        blocks.util.footer()

    def new_simple [html] (self, request):
        blocks.util.set_menu_mode(request, 'new')
        title = 'Create a Simple Poll'
        
        cur_user = get_user()
        
        if self.polls.can_pay_for_new_item(cur_user):
            h = '''
            <p class="formHelp">Simple polls allow for two choices.
            For more advanced polling options, go back and choose to create a Custom Poll.
            All fields marked with an asterisk are required.
            </p>
            '''
            footer_text = '''<p><span class="alert">NOTE:</span> %d point will be deducted from your feedback
            bank to create a new poll.</p>''' % self.polls._karma_new_item
            if _ROLLOUT_TEST:
                footer_text += '''<p><span class="alert">This feature is currently being tested:</span> no points will actually be deducted from your feedback
                bank.</p>'''
            
            manage_form(request, NewSimplePollForm,
                page_title=title,
                heading_text=h,
                footer_text=footer_text,
                preview_text='''<p class="alert">Verify your settings and make any necessary changes below. Be sure to hit the Start Poll button to start your poll.</p>''',
                commit_text='%s',
                commit_repl='RESULT',
                access_test=cur_user and self.ihb.can_edit(cur_user),
                access_sorry='<p class="alert">Sorry, you don\'t have permission to create a new poll.</p>',
                polls=self.polls,
                user=cur_user)
        else:
            self._not_enough_karma_to_create(request, title)

    def new_custom [html] (self, request):
        blocks.util.set_menu_mode(request, 'new')
        title = 'Create a Custom Poll'
        
        cur_user = get_user()
        
        if self.polls.can_pay_for_new_item(cur_user):
            
            preview_text = None
            form_class = NewCustomPollForm
            h = '''<h2>Step 1 of 4</h2>
            <p class="formHelp">Set your poll's title, description,
            and the number of choices voters will have to choose from.
            All fields marked with an asterisk are required.
            </p>
            '''
            s = request.get_form_var('s')
            if s == '2':
                form_class = NewCustomPollForm2
                h = '''<h2>Step 2 of 4</h2>
                <p class="formHelp">Enter the names for each of the choices, and designate the number
                of choices your voters must select.
                All fields marked with an asterisk are required.
                </p>
                '''
            elif s == '3':
                form_class = NewCustomPollForm3
                h = '''<h2>Step 3 of 4</h2>
                <p class="formHelp">Almost done! (Whew.) Choose the number of days the poll will be open
                from the moment you start the poll. You can also choose to restrict the people who
                can vote or can who see the results, as well as other options.
                All fields marked with an asterisk are required.
                </p>
                '''
            elif s == '4':
                form_class = NewCustomPollForm4
		preview_text=' '
                h = '''<h2>Step 4 of 4</h2>'''
            
            footer_text = '''<p><span class="alert">NOTE:</span> %d point will be deducted from your feedback
            bank to start this new poll.</p>''' % self.polls._karma_new_item
            
            if _ROLLOUT_TEST:
                footer_text += '''<p><span class="alert">This feature is currently being tested:</span> no points will actually be deducted from your feedback
                bank.</p>'''

            manage_form(request, form_class,
                page_title=title,
                heading_text=h,
                footer_text=footer_text,
                preview_text=preview_text,
                commit_text='%s',
                commit_repl='RESULT',
                access_test=cur_user and self.ihb.can_edit(cur_user),
                access_sorry='<p class="alert">Sorry, you don\'t have permission to create a new poll.</p>',
                polls=self.polls,
                user=cur_user)
        else:
            self._not_enough_karma_to_create(request, title)

    def _not_enough_karma_to_create [html] (self, request, title):
        blocks.util.header(request, title)
        '''<h1>%s</h1>''' % title
        '''<p class="alert">Sorry, you don't have enough points in your feedback bank to create a new poll.</p>
        <p>It costs %d point to create a new poll.
        You have %d points in your feedback bank.
        You can earn more points in your feedback bank
        through your activity on the site, such as reading, posting comments or contributing to workspace pages.
        You also earn points quickly whenever you receive positive feedback from other users.</p>
        ''' % (self.polls._karma_new_item, get_user().get_karma_bank_balance())
        blocks.util.footer()

    def watch(self, request):
        return qon.ui.util.watch(request, self.polls)
        
    def unwatch(self, request):
        return qon.ui.util.unwatch(request, self.polls)        

class PollItemUI(QonBaseUI):

    _q_exports = ['results', 'cancel', 'watch', 'unwatch', 'email']

    _user_tally_per_page = 25
    
    def __init__(self, request, polls, index):
        self.polls = polls
        self.ihb = polls.ihb
        self.index = index
        self.poll = polls.get_poll(index)
        self.cur_user = get_user()
        
        if not self.poll:
            raise TraversalError
        
        if not self.cur_user:
            raise AccessError
        
        blocks.util.set_watchable_item(request, self.poll)      

        menus = [
            {
                'name': 'Cancel Poll',
                'path': 'cancel',
                'title': 'Cancel an active poll.',
                'disabled': not self.poll.is_active() or ((self.cur_user is not self.poll.creator) and (not self.ihb.is_owner(self.cur_user))),
            },
            {
                'name': 'Results',
                'path': 'results',
                'title': 'View poll results.',
                'disabled': self.poll.is_active() and not self.poll.can_see_intermediate_results(self.cur_user),
            },
            ]
        blocks.util.set_menus(request, menus)

    def get_crumb(self):
        return blocks.util.format_string(self.poll.title)
    
    def _poll_info [html] (self, show_ended_results_link=True):
        d = {}
        
        d['creator'] = blocks.util.display_name(self.poll.creator)
        d['date'] = blocks.util.format_datetime(self.poll.date)
        d['end_date'] = blocks.util.format_datetime(self.poll.end_date)
        
        '''
        <p>
        <span class="title">Created by:</span> %(creator)s<br />
        <span class="title">Start date:</span> %(date)s<br />
        ''' % d
        
        if self.poll.is_active():
            d['time_left'] = blocks.util.format_time_left(self.poll.end_date, prefix='', detail=True)
            '''
            <span class="title">Poll ends:</span> %(end_date)s<br />
            <span class="title">Time left:</span> %(time_left)s<br />
            </p>
            ''' % d
        else:
            '''
            <span class="title">Poll ended:</span> %(end_date)s<br />
            </p>
            <p><span class="info">Voting on this poll has ended.</span>
            ''' % d
            
            if show_ended_results_link:
                '''(<a href="results">results</a>)'''
            '''</p>'''
    
    def _poll_extended_info [html] (self):
        safe_yes = '''<span class="info">yes</span>'''
        safe_anonymous = '''<span class="info">yes, all votes are anonymous</span>'''
        unsafe_no = '''<span class="alert">no</span>'''
        unsafe_full_disclosure = '''<span class="alert">no, names of voters are revealed, along with how they voted</span>'''
        unsafe_log_shown = '''<span class="alert">semi-anonymous, names of voters are revealed but how voters voted is hidden</span>'''
        
        pd = self.poll.get_data()
        
        d = {}

        if pd.voter_can_revise:
            d['can_revise'] = safe_yes
        else:
            d['can_revise'] = unsafe_no

        if pd.display_voters == 'full':
            d['vote_anon'] = unsafe_full_disclosure
        elif pd.display_voters == 'log_only':
            d['vote_anon'] = unsafe_log_shown
        elif pd.display_voters == 'anon':
            d['vote_anon'] = safe_anonymous

        if pd.vote_access == 'all':
            d['who_vote'] = 'anyone'
        elif pd.vote_access == 'member':
            d['who_vote'] = 'group members'
        elif pd.vote_access == 'owner':
            d['who_vote'] = 'group owners'

        if pd.results_access == 'all':
            d['who_results'] = 'anyone'
        elif pd.results_access == 'member':
            d['who_results'] = 'group members'
        elif pd.results_access == 'owner':
            d['who_results'] = 'group owners'

        if pd.intermediate_access == 'none':
            d['who_intermediate'] = 'no one'
        elif pd.intermediate_access == 'all':
            d['who_intermediate'] = 'anyone'
        elif pd.intermediate_access == 'member':
            d['who_intermediate'] = 'group members'
        elif pd.intermediate_access == 'owner':
            d['who_intermediate'] = 'group owners'
        
        if pd.intermediate_access != 'none':
            if pd.vote_required_to_view:
                d['who_intermediate'] += ', after voting'
            else:
                d['who_intermediate'] += ', even before voting'
        
        '''
        <h2>Poll settings</h2>
        <p class="subtitle">
        <span class="title">Voter can revise vote:</span> %(can_revise)s<br />
        <span class="title">Voter identity protected:</span> %(vote_anon)s<br />
        <span class="title">Who can vote:</span> %(who_vote)s<br />
        <span class="title">Who can see results:</span> %(who_results)s<br />
        <span class="title">Who can view results before poll ends:</span> %(who_intermediate)s<br />
        </p>
        ''' % d
        
    def _poll_user_vote [html] (self):
        # display current user's vote in this poll
        votes = self.poll.user_vote_choices(self.cur_user)
        '''<ul>'''
        for v in votes:
            '''<li>%s</li>''' % v
        '''</ul>'''
    
    def _poll_tally [html] (self):
        pd = self.poll.get_data()
        
        '''
        <p>
        <span class="title">Votes cast:</span> %s
        </p>
        ''' % self.poll.num_votes_cast()
        
        tally = pd.tally_choices()
        
        rows = []
        index = 0
        for choice in pd.choices:
            rows.append((choice, tally[index]))
            index += 1
        blocks.util.format_table_rows(rows, headings=['Item', 'Count'])
        
        if pd.min_choice != pd.max_choice:
            '''
            <p><span class="alert">Note:</span> Individual vote totals may not add up to
            the total number of votes cast, because this poll allows a variable number
            of choices.
            </p>
            '''
            
            
    def _poll_user_tally [html] (self, nav_path='', reveal_votes):
        user_db = get_user_database()
        user_votes = self.poll.user_votes_choices().items()
        
        num_entries = len(user_votes)
        page, start = qon.ui.util.get_page_start(self._user_tally_per_page)
        
        # sort list of voters by display name
        byname = []
        for user_id, votes in user_votes:
            user = user_db.get_user(user_id)
            byname.append((user.display_name(), user, votes))
        
        byname.sort()

        rows = []
        for user_dn, user, votes in byname[start:start+self._user_tally_per_page]:
            if reveal_votes:
                votes = ', '.join(votes)
            else:
                votes = 'hidden'
            rows.append((
                blocks.util.display_name(user),
                votes,
                ))
        blocks.util.format_table_rows(rows, headings=['User', 'Votes'])

        num_pages = (num_entries - 1) / self._user_tally_per_page + 1
        if num_pages > 1:
            '''<h2>%spage %s</h2>''' % (
                blocks.util.get_pagenav(page, num_pages, '''<a href="./results?page=%s">'''),
                page)

    def _poll_results [html] (self, nav_path=''):
        '''
        <h2>Poll results</h2>
        '''
        if self.poll.can_see_results(self.cur_user):
            if self.poll.get_data().display_voters == 'full':
                self._poll_tally()
                self._poll_user_tally(nav_path=nav_path, reveal_votes = True)
            elif self.poll.get_data().display_voters == 'log_only':
                self._poll_tally()
                if not self.poll.is_active():
                    self._poll_user_tally(nav_path=nav_path, reveal_votes = False)
            elif self.poll.get_data().display_voters == 'anon':
                self._poll_tally()
            
        else:
            pd = self.poll.get_data()
            if pd.results_access == 'member':
                see = 'members'
            else:
                see = 'owners'
            '''<p class="alert">Only group %s can view the results of this poll.</p>''' % see
            
    def _poll_choices [html] (self):
        '''<h2>Poll choices</h2>
        <p class="formHelp">All the poll's choices are listed here for your reference.</p>
        '''
        self._multiple_choice_help(mute_text=True)
        
        poll_choices = self.poll.get_data().choices[:]
        '''<ul>'''
        for choice in poll_choices:
            '''<li>%s</li>''' % choice
        '''</ul>'''
        
        
    def _ended_poll [html] (self, request, title):
        blocks.util.header(request, title)
        '''<h1>%s</h1>''' % self.poll.title
        
        # heading
        self._poll_info()
        
        # description
        htmltext(self.poll.get_cached_html())
        
        # user's vote
        if self.poll.has_voted(self.cur_user):
            '''<p class="info">You have voted in this poll.</p>
            <p>You voted for the following item(s):</p>'''
            self._poll_user_vote()
        
        # poll choices
        self._poll_choices()
        
        # extra info
        self._poll_extended_info()
        
        blocks.util.footer()
    
    def _already_voted [html] (self, request, title):
        blocks.util.header(request, title)
        '''<h1>%s</h1>''' % self.poll.title
        self._poll_info()
        
        htmltext(self.poll.get_cached_html())
        
        '''<p><span class="info">You have voted in this poll.</span>'''

        if self.poll.can_see_intermediate_results(self.cur_user):
            ''' (View <a href="results">results</a>)'''
        elif self.poll.can_see_results(self.cur_user):
            ''' You will have to wait until the end of the poll to see the results.'''
        else:
            ''' According to this poll's settings, you will not be able to see the results.'''
        
            
        '''</p>
        <p>You voted for the following item(s):</p>'''
        self._poll_user_vote()
        
        self._poll_choices()
        
        self._poll_extended_info()
        
        blocks.util.footer()
    
    def _multiple_choice_help [html] (self, mute_text=False):
        pd = self.poll.get_data()
        
        if pd.min_choice == 1 and pd.max_choice == 1:
            return ''
        
        if mute_text:
            p_class = ''
        else:
            p_class = ' class="alert"'
        
        if pd.min_choice == pd.max_choice:
            '''<p%s>Choose exactly %d:</p>''' % (p_class, pd.min_choice)
        else:
            '''<p%s>Choose at least %d and at most %d:</p>''' % (p_class, pd.min_choice, pd.max_choice)
        
    def _active_poll_page [html] (self, request, title, error_text=None):
        _extra_karma_cost_warning = 10
        
        h = '''<h1>%s</h1>''' % self.poll.title
        h += self._poll_info()
        h += htmltext(self.poll.get_cached_html())
        
        if error_text:
            h += error_text
        
        if self.poll.has_voted(self.cur_user):
            if self.poll.can_see_intermediate_results(self.cur_user):
                h += '''<p><span class="info">You have voted in this poll.</span> (View <a href="results">results</a>)<br />'''
            else:
                h += '''<p><span class="info">You have voted in this poll.</span><br />'''

            h += '''<span class="formHelp">Your current vote is shown below, but you may revise it before the poll ends.</span></p>'''
            again = ' again'
        else:
            again = ''
        
        if self.poll.get_data().display_voters == 'full':
            h += '''<p><span class="alert">Warning: This poll does <strong>not</strong> protect your identity.</span><br />
            <span class="formHelp">How you voted will be available to anyone who can see the results.</span>
            </p>
            '''
        elif self.poll.get_data().display_voters == 'log_only':
            h += '''<p><span class="alert">Note:</span> This poll is not completely anonymous.<br />
            <span class="formHelp">Your name will be revealed to show you voted in this poll to anyone who can see the results, although how you vote will remain hidden.</span>
            </p>
            '''
        
        footer_text = ''
        karma_cost = self.poll.get_data().karma_cost
        if karma_cost:
            footer_text += '''<p><span class="alert">Note:</span> %d point(s) will be deducted from your feedback
            bank to vote in this poll%s.</p>''' % (karma_cost, again)
            
            if karma_cost >= _extra_karma_cost_warning:
                h += '''
                <p class="alert">Warning: Voting in this poll will cost you %d points from your feedback bank.</p>''' % karma_cost
            
            if _ROLLOUT_TEST:
                footer_text += '''<p><span class="alert">This feature is currently being tested:</span> No points will actually be deducted
                from your bank to vote.</p>'''
        else:
            footer_text += '''<p><span class="info">Note:</span> there is no cost to vote in this poll%s.</p>''' % (again)
            
        footer_text += self._poll_extended_info()
        
        h += self._multiple_choice_help()
        
        manage_form(request, PollForm,
            page_title=title,
            suppress_top_heading=1,
            heading_text=h,
            footer_text=footer_text,
            commit_title="Vote recorded.",
            commit_text='<p class="info">Your vote has been recorded.</p>',
            poll=self.poll,
            user=self.cur_user,
            no_vote=error_text is not None,
            )
    
    def _q_index [html] (self, request):
        # cookie this page
        blocks.util.cookie_this_page(self.poll)
        
        # declare this as emailable
        blocks.util.set_emailable_item(request, self.poll)  
        
        title = 'ned.com Poll: %s' % blocks.util.format_string(self.poll.title)
        
        error_text = None
        
        # ended poll
        if not self.poll.is_active():
            self._ended_poll(request, title)
        
        # check for voter who has already voted and is not allowed to revise
        elif self.poll.has_voted(self.cur_user) and not self.poll.can_vote(self.cur_user):
            self._already_voted(request, title)
        
        # otherwise we'll display a polling page, possibly with an error
        else:
            if not self.poll.can_pay_for_vote(self.cur_user):
                # can't pay for vote
                error_text = '''
                    <p class="alert">Sorry, you don't have enough points in your bank to vote in this poll.</p>
                    <p>It costs <strong>%d</strong> point to vote in this poll.
                    You have %d points in your feedback bank.
                    You can earn more points in your feedback bank
                    through your activity on the site, such as reading, posting comments or contributing to workspace pages.
                    You also earn points quickly whenever you receive positive feedback from other users.</p>
                    ''' % (self.poll.get_data().karma_cost, self.cur_user.get_karma_bank_balance())
    
            elif not self.poll.enough_karma_to_vote(self.cur_user):
                # not enough karma
                error_text = '''
                    <p class="alert">Sorry, your feedback score is not high enough to vote in this poll.</p>
                    <p>Your feedback score must be at least <strong>%d</strong> point(s) to vote in this poll.</p>
                    ''' % (self.poll.get_data().min_karma)
    
            elif not self.poll.old_enough_to_vote(self.cur_user):
                # not old enough
                error_text = '''
                    <p class="alert">Sorry, members who joined after this poll started are not allowed to vote.</p>
                    '''
    
            # voter can vote in this poll
            elif not self.poll.can_vote(self.cur_user):
                # no permission to vote
                error_text = '''
                   <p class="alert">Sorry, you don't have permission to vote in this poll.</p>
                   '''
    
            # we passed all texts, or we set an error to display on the active poll page
            self._active_poll_page(request, title, error_text)

    def results [html] (self, request):
        title = 'ned.com Poll Results: %s' % blocks.util.format_string(self.poll.title)
        
        if (not self.poll.is_active()) or self.poll.can_see_intermediate_results(self.cur_user):
            blocks.util.header(request, title)
            '''<h1>%s</h1>''' % self.poll.title
            self._poll_info(show_ended_results_link=False)
            # description
            htmltext(self.poll.get_cached_html())
            self._poll_results(nav_path='''<a href="./results?page=%s">''')
            self._poll_extended_info()
            blocks.util.footer()
        else:
            blocks.util.header(request, title)
            '''<h1>%s</h1>''' % self.poll.title
            '''
            <p class="alert">Results are not available until the poll closes.</p>
            '''
            blocks.util.footer()

    def cancel [html] (self, request):
        if not self.poll.is_active():
            raise TraversalError
            
        title = 'Canceling poll: %s' % blocks.util.format_string(self.poll.title)

        blocks.util.set_menu_mode(request, 'cancel')
        
        # creator or manager can delete item
        access_test = ((self.poll.creator == self.cur_user) or self.polls.ihb.can_manage(self.cur_user))
        
        manage_form(request, CancelItemForm,
            page_title=title,
            heading_text='<p class="alert">Are you sure you want to cancel this poll?</p>',
            commit_text='<p class="info">The poll has been canceled.</p>',
            access_test=access_test,
            access_sorry='<p class="alert">Sorry, you don\'t have permission to cancel this poll.</p>',
            poll=self.poll)

    def watch(self, request):
        return qon.ui.util.watch(request, self.poll)
        
    def unwatch(self, request):
        return qon.ui.util.unwatch(request, self.poll)

    def email [html] (self, request):
        return blocks.action.email_this_page(request, self.poll)               
    
def format_poll_row(poll, now=None, with_results=False):
    
    # title
    if poll.has_voted(get_user()):
        title_format = '''%s<br /><span class="subtitle">By %s</span>'''
    else:
        title_format = '''<strong>%s</strong><br /><span class="subtitle">By %s</span>'''
    
    title = htmltext(title_format % (
            href(path_to_poll(poll), blocks.util.format_string(poll.title, max_len=80)),
            blocks.util.display_name(poll.creator)))
    
    # num votes
    if with_results:
        num_votes_text = htmltext('''%d<br /><span class="subtitle">(<a href="%s">results</a>)</span>''') % (
            poll.num_votes_cast(),
            path_to_poll(poll) + 'results'
            )
    else:
        num_votes_text = '%d' % poll.num_votes_cast()
    
    # date
    if not now:
        now = datetime.utcnow()

    if now <= poll.end_date:
        time = blocks.util.format_time_left(poll.end_date)
    else:
        time = blocks.util.format_datetime_shorter(poll.end_date)

    return (
        title,
        num_votes_text,
        time,
        )

def path_to_polls(group):
    from qon.ui.blocks.group import path_to_group
    return path_to_group(group) + 'poll/'
    
def path_to_poll(poll):
    return path_to_polls(poll.container.ihb) + '%d/' % poll.get_item_index()


class NewSimplePollForm(QonForm):
    submit_button = 'submit-newpoll'
    preview_button = 'preview-newpoll'
    cancel_button = 'cancel-newpoll'
    submit_buttons = [preview_button, submit_button, cancel_button]
    
    def __init__(self, polls=None, user=None):
        QonForm.__init__(self)
        self.polls = polls
        self.user = user
        self._build_form()
    
    def _build_form(self):
        self.add_string('title', title="Title", required=True, size=64,
            hint='''e.g. Zebra Stripes Poll''',
            )
        self.add_text('description', title="Description", required=True, rows=5, cols=60,
            hint="e.g. Is a zebra's coat black with white stripes or white with black stripes?",
            )
        self.add_int('duration', value=1, title="Duration", required=True, size=2,
            hint="Number of days poll will be open, between 1 and 7.")
        self.add_string('choice1', title="Choice 1", value='Yes', required=True, size=32,
            hint="e.g. black coat with white stripes",
            )
        self.add_string('choice2', title="Choice 2", value='No', required=True, size=32,
            hint="e.g. white coat with black stripes",
            )
        
        self.add_submit(self.cancel_button, value="Cancel")
        self.add_submit(self.preview_button, value="Preview")
        self.add_submit(self.submit_button, value="Start Poll")
            
    def validate(self):
        if not QonForm.validate(self):
            return False
            
        if self.get_submit() == self.cancel_button:
            return True

        if self['duration'] < 1 or self['duration'] > 7:
            self.set_error('duration', "You must enter a number between 1 and 7.")
            return False
        
        if self['choice1'].lower().strip() == self['choice2'].lower().strip():
            self.set_error('choice2', "Hmm, both choices are the same... is that really voting?")
            return False
        
        return True
        
    def preview [html] (self):
        '''
        <p>
        <span class="title">Title:</span> %(title)s<br />
        <span class="title">Description:</span>
        </p>
        <blockquote>%(description)s</blockquote>
        <p>
        <span class="title">Choice 1:</span> %(choice1)s<br />
        <span class="title">Choice 2:</span> %(choice2)s<br />
        <span class="title">Duration:</span> %(duration)s day(s)<br />
        </p>
        <hr noshade="noshade" />
        ''' % dict(
            title=self['title'],
            duration=self['duration'],
            choice1=self['choice1'],
            choice2=self['choice2'],
            description=blocks.blog.format_blog_content(self.polls.ihb.get_blog(), self['description']),
            )
        
        self.render()

    def commit(self):
        if self.get_submit() == self.submit_button:
            choices = [self['choice1'].strip(), self['choice2'].strip()]
            
            # create the poll
            poll = api.poll_create(
                polls=self.polls,
                creator=get_user(),
                title=self['title'].strip(),
                description=self['description'].strip(),
                end_date=datetime.utcnow() + timedelta(days=self['duration']),
                choices=choices,
                )
            if poll:
                return get_request().redirect(path_to_poll(poll))
            else:
                return htmltext('''
                <p class="alert">An error occurred trying to create the poll. Please try again.</p>
                ''')

        return get_request().redirect('./new')
                
class NewCustomPollForm(QonForm):
    submit_button = 'submit-newpoll'
    cancel_button = 'cancel-newpoll'
    submit_buttons = [submit_button, cancel_button]
    
    def __init__(self, polls=None, user=None):
        QonForm.__init__(self)
        self.polls = polls
        self.user = user
        self._build_form()
    
    def _build_form(self):
        self.add_string('title', title="Title", required=True, size=60,
            hint='''e.g. Zebra Stripes Poll''',
            )
        self.add_text('description', title="Description", required=True, rows=5, cols=60,
            hint="e.g. Is a zebra's coat black with white stripes or white with black stripes?",
            )
        self.add_int('numchoices', title="Number of choices", required=True, size=2,
            hint="Number of choices presented to voters. You'll identify these choices in the next step.")

        # fill form with prior form's values saved in session (for back button)
        vars = self.read_session(form_class=NewCustomPollForm)
        self.clear_session(form_class=NewCustomPollForm)

        self.add_submit(self.cancel_button, value="Cancel")
        self.add_submit(self.submit_button, value="Go to Step 2...")
        
    def validate(self):
        if not QonForm.validate(self):
            return False
            
        if self.get_submit() != self.submit_button:
            return True

        num_error = "You must enter a number between 1 and 99."
        
        try:
            num = int(self['numchoices'])
        except ValueError:
            self.set_error('numchoices', num_error)
            return False
            
        if num < 1 or num > 99:
            self.set_error('numchoices', num_error)
            return False
        
        return True
        
    def commit(self):
        if self.get_submit() == self.submit_button:
            self.write_session()
            return get_request().redirect('./new_custom?s=2')

        return get_request().redirect('./new')

class NewCustomPollForm2(QonForm):
    submit_button = 'submit-newpoll2'
    cancel_button = 'cancel-newpoll2'
    submit_buttons = [submit_button, cancel_button]
    
    def __init__(self, polls=None, user=None):
        QonForm.__init__(self)
        self.polls = polls
        self.user = user
        
        # if we're entering this form with a GET request, we need
        # to clear out any query_string form vars that might be lingering,
        # e.g. the ?s=2 that we used to get here. Not doing so would make
        # the form framework think we just submitted this form and would
        # try to validate it, resulting in errors for all the required fields
        request = get_request()
        if request.get_method() == 'GET':
            request.form = {}
        
        self._build_form()
        
    def _build_form(self):
        # widgets from prior form
        self.add_hidden('title')
        self.add_hidden('description')
        self.add_hidden('numchoices')
        
        # fill form with prior form's values saved in session
        vars = self.read_session(form_class=NewCustomPollForm)

        # new widgets
        
        # get number of widgets from prior form
        num_choices = int(self['numchoices']) + 1
        
        for i in range(1, num_choices):
            self.add_string('choice%d' % i, title='Choice %d' % i, required=True, size=32)
            
        # min/max
        # must use str values here for read_session to properly override
        # the vals: SelectWidget.set_value uses an == check
        self.add_single_select('choice_min', title='Voter must select at least this many choices:',
            options=[str(i) for i in range(1, num_choices)],
            hint='For simple "pick one" votes, make both these numbers "1".',
            required=True)

        self.add_single_select('choice_max', title='Voter must select no more than this many choices:',
            options=[str(i) for i in range(1, num_choices)],
            hint='For simple "pick one" votes, make both these numbers "1".',
            required=True)
        
        # fill form with prior form's values saved in session
        vars = self.read_session(form_class=NewCustomPollForm)
        self.clear_session(form_class=NewCustomPollForm)

        # step indicator
        self.add_hidden('s', value="2")
        
        self.add_submit(self.cancel_button, value="Back")
        self.add_submit(self.submit_button, value="Go to Step 3...")
                    
    def validate(self):
        if not QonForm.validate(self):
            return False
        
        if self['choice_min'] > self['choice_max']:
            self.set_error('choice_max', "This number must not be smaller than the first number.")
            return False
        
        # check all choices are unique
        seen = {}
        num_choices = int(self['numchoices']) + 1
        for i in range(1, num_choices):
            choice = self['choice%d' % i]
            
            if not choice:
                self.set_error('choice%d' % i, "required")
                return False

            choice = choice.lower().strip()
            if seen.has_key(choice):
                self.set_error('choice%d' % i, "Hmm, this choice looks like a duplicate of a previous choice.")
                return False
            seen[choice] = 1

        return True

    def commit(self):
        if self.get_submit() == self.submit_button:
            self.write_session()
            return get_request().redirect('./new_custom?s=3')
        else:
            self.write_session(form_class=NewCustomPollForm)
            return get_request().redirect('./new_custom')

class NewCustomPollForm3(QonForm):
    submit_button = 'submit-newpoll3'
    cancel_button = 'cancel-newpoll3'
    submit_buttons = [submit_button, cancel_button]
    
    def __init__(self, polls=None, user=None):
        QonForm.__init__(self)
        self.polls = polls
        self.user = user
        
        # see note in NewCustomPollForm2.__init__
        request = get_request()
        if request.get_method() == 'GET':
            request.form = {}
        
        self._build_form()
        
    def _build_form(self):
        # widgets from prior form
        self.add_hidden('title')
        self.add_hidden('description')
        self.add_hidden('numchoices')
        self.add_hidden('choice_min')
        self.add_hidden('choice_max')
        
        # fill form with prior form's values saved in session
        vars = self.read_session(form_class=NewCustomPollForm2)
        
        # create choice widgets
        num_choices = int(self['numchoices']) + 1
        
        for i in range(1, num_choices):
            self.add_hidden('choice%d' % i)
        
        # new widgets
        
        self.add_int('duration', value=1, title="Duration", required=True, size=2,
            hint="Number of days poll will be open, between 1 and 90.")
        
        self.add_radiobuttons('vote-pol', title="Who can vote in this poll?",
            options=[('owner', 'Only Group owners'),
                ('member', 'Group members'),
                ('all', 'Anyone'),
            ],
            hint="Important: Only members whose accounts were created before you start the poll can vote.",
            value='member',
            required=True,
            sort=False)

        self.add_radiobuttons('results-pol', title="Who can see the final results?",
            options=[('owner', 'Only Group owners'),
                ('member', 'Group members'),
                ('all', 'Anyone'),
            ],
            value='member',
            required=True,
            sort=False)

        self.add_radiobuttons('intermediate-pol', title="Who can see results before the poll closes?",
            options=[('none', 'No one'),
                ('owner', 'Only Group owners'),
                ('member', 'Group members'),
                ('all', 'Anyone'),
            ],
            value='none',
            required=True,
            sort=False)

        self.add_radiobuttons('vote-to-see-pol', title="Vote required to see results before poll closes?",
            options=[('yes', 'Yes (recommended)'),
                ('no', 'No'),
            ],
            value='yes',
            required=True,
            sort=False)

        self.add_radiobuttons('vote-again-pol', title="Can voters revise their votes prior to poll closing?",
            options=[('yes', 'Yes'),
                ('no', 'No (recommended)'),
            ],
            hint="No is recommended especially if voters can view results prior to poll closing.",
            value='no',
            required=True,
            sort=False)

        self.add_radiobuttons('display-voters', title="Is voting anonymous?",
            options=[('anon', 'Yes'),
                ('full', 'No'),
                ('log_only', 'Semi-Anonymous'),
                     
            ],
            hint='''If "no," all voters' names will be displayed next to how they voted. If "semi-anonymous," a log of voters' names will be displayed, but how they vote will not.''',
            value='anon',
            required=True,
            sort=False)

        self.add_int('min-feedback', value=0, title="Minimum feedback score required to vote:",
            required=True, size=4,
            hint="Any number, positive or negative.")

        self.add_int('cost', value=1, title="Cost to voter each time a vote is cast:",
            required=True, size=4,
            hint="Cost will be deducted from voter's feedback bank when they vote.")

        # read session again to fill the widgets
        # do this after all widgets are created in case we are here
        # using the Back button, in which case widget values need to be overriden
        vars = self.read_session(form_class=NewCustomPollForm2)
        self.clear_session(form_class=NewCustomPollForm2)

        # step indicator
        self.add_hidden('s', value="3")
        
        self.add_submit(self.cancel_button, value="Back")
        self.add_submit(self.submit_button, value="Go to Step 4...")
                    
    def validate(self):
        if not QonForm.validate(self):
            return False
            
        if self.get_submit() != self.submit_button:
            return True

        if self['duration'] < 1 or self['duration'] > 90:
            self.set_error('duration', "You must enter a number between 1 and 90.")
            return False
            
        if self['cost'] < 0:
            self.set_error('cost', "You must enter zero or more points.")
            return False
            
        return True
        
    def commit(self):
        if self.get_submit() == self.submit_button:
            self.write_session()
            return get_request().redirect('./new_custom?s=4')
        else:
            self.write_session(form_class=NewCustomPollForm)
            return get_request().redirect('./new_custom?s=2')

class NewCustomPollForm4(QonForm):
    submit_button = 'submit-newpoll4'
    preview_button = 'preview-newpoll4'
    cancel_button = 'cancel-newpoll4'
    submit_buttons = [preview_button, submit_button, cancel_button]
    
    def __init__(self, polls=None, user=None):
        QonForm.__init__(self)
        self.polls = polls
        self.user = user
        
        # see note in NewCustomPollForm2.__init__
        request = get_request()
        if request.get_method() == 'GET':
            request.form = {}
        
        self._build_form()
        
    def _build_form(self):
        # widgets from prior form
        self.add_string('title', title="Title", required=True, size=60)
        self.add_text('description', title="Description", required=True, rows=5, cols=60)

        self.add_hidden('numchoices')
        self.add_hidden('choice_min')
        self.add_hidden('choice_max')
        self.add_hidden('duration')
        self.add_hidden('vote-pol')
        self.add_hidden('results-pol')
        self.add_hidden('intermediate-pol')
        self.add_hidden('vote-to-see-pol')
        self.add_hidden('vote-again-pol')
        self.add_hidden('display-voters')
        self.add_hidden('min-feedback')
        self.add_hidden('cost')

        # fill form with prior form's values saved in session
        vars = self.read_session(form_class=NewCustomPollForm3)
        
        # get number of widgets from prior form
        num_choices = int(self['numchoices']) + 1
        
        for i in range(1, num_choices):
            self.add_string('choice%d' % i, title='Choice %d' % i, required=True, size=32)
        
        # read session again to fill the choice widgets
        vars = self.read_session(form_class=NewCustomPollForm3)
        self.clear_session(form_class=NewCustomPollForm3)

        # new widgets
        
        # step indicator
        self.add_hidden('s', value="4")

        self.add_submit(self.cancel_button, value="Back")
        self.add_submit(self.preview_button, value='Preview')
        self.add_submit(self.submit_button, value="Start Poll!")
    
    def _get_preview_vars(self):

        pol = dict(owner='Only Group owners',
            member='Group members',
            all='Anyone',
            none='No one',
            yes='Yes',
            no='No',
            full='No',
            log_only='Semi-Anonymous',
            anon='Yes'
            )

        d = {}
        d['title'] = self['title']
        d['description'] = blocks.blog.format_blog_content(self.polls.ihb.get_blog(), self['description'])
        d['min_choice'] = self['choice_min']
        d['max_choice'] = self['choice_max']
        d['duration'] = self['duration']
        d['min-feedback'] = self['min-feedback']
        d['cost'] = self['cost']

        d['vote-pol'] = pol[self['vote-pol']]
        d['results-pol'] = pol[self['results-pol']]
        d['intermediate-pol'] = pol[self['intermediate-pol']]
        d['vote-to-see-pol'] = pol[self['vote-to-see-pol']]
        d['vote-again-pol'] = pol[self['vote-again-pol']]
        d['display-voters'] = pol[self['display-voters']]
        
        # if no one can see intermediate results, the vote-to-see option is not applicable
        if self['intermediate-pol'] == 'none':
            d['vote-to-see-pol'] = 'Not applicable'
        
        return d
    
    def _get_num_choices(self):
        return int(self['numchoices']) + 1

    def preview [html] (self):
	self.render()

    def render [html] (self):
        # render preview of poll
        d = self._get_preview_vars()
        
        '''
        <p><span class="alert">Please check your settings and hit Start Poll to start your poll!</span><br />
        <span class="formHelp">Polls settings <strong>cannot</strong> be changed once the poll is started. If you
        made a mistake, you will have to cancel your poll and start a new one.</span></p>
        
        <h2>Settings</h2>
        <p>
        <span class="title">Duration:</span> %(duration)s day(s)<br />
        <span class="title">Who can vote in this poll:</span> %(vote-pol)s<br />
        <span class="title">Who can see the final results:</span> %(results-pol)s<br />
        <span class="title">Who can see results before the poll closes:</span> %(intermediate-pol)s<br />
        <span class="title">Vote required to see results before poll closes:</span> %(vote-to-see-pol)s<br />
        <span class="title">Can voters revise their votes prior to poll closing:</span> %(vote-again-pol)s<br />
        <span class="title">Voting is anonymous:</span> %(display-voters)s<br />
        <span class="title">Minimum feedback score required to vote:</span> %(min-feedback)s<br />
        <span class="title">Cost to voter each time a vote is cast:</span> %(cost)s<br />
        </p>
        ''' % d
        
        # choices
        num_choices = self._get_num_choices()
        
        '''
        <h2>Choices</h2>
        <p>
        <span class="title">Voter must choose at least:</span> %(min_choice)s<br />
        <span class="title">Voter must choose no more than:</span> %(max_choice)s<br />
        ''' % d
        
        '''</p>'''

        '''<p>
        <h2>Preview</h2>
        <p>
        <span class="title">Title:</span> %(title)s<br />
        <span class="title">Description:</span>
        </p>
        <blockquote>%(description)s</blockquote>
        ''' % d
        
        for i in range(1, num_choices):
            '''<span class="title">Choice %d:</span> %s<br />''' % (i, self[str('choice%d'%i)])

	'''
	<p>
        <hr noshade="noshade" />
	</p>
        '''

        # render form with submit buttons
        QonForm.render(self)
        
    def commit(self):
        if self.get_submit() == self.submit_button:
            
            # make choices list
            num_choices = int(self['numchoices']) + 1
            choices = []
            for i in range(1, num_choices):
                choices.append(self['choice%d'%i])
                
            # make custom dict
            
            bt = dict(yes=True,no=False)
            
            custom = {}
            custom['min_choice'] = int(self['choice_min'])
            custom['max_choice'] = int(self['choice_max'])
            custom['vote_access'] = self['vote-pol']
            custom['results_access'] = self['results-pol']
            custom['intermediate_access'] = self['intermediate-pol']
            custom['vote_required_to_view'] = bt[self['vote-to-see-pol']]
            custom['voter_can_revise'] = bt[self['vote-again-pol']]
            custom['display_voters'] = self['display-voters']
            custom['min_karma'] = int(self['min-feedback'])
            custom['karma_cost'] = int(self['cost'])
            
            poll = api.poll_create_custom(
                polls=self.polls,
                creator=get_user(),
                title=self['title'].strip(),
                description=self['description'].strip(),
                end_date=datetime.utcnow() + timedelta(days=int(self['duration'])),
                choices=choices,
                custom=custom,
                )
            
            if poll:
                get_request().redirect(path_to_poll(poll))
            else:
                return htmltext('''
                <p class="alert">An error occurred trying to create the poll. Please try again.</p>
                ''')
        else:
            self.write_session(form_class=NewCustomPollForm2)
            return get_request().redirect('./new_custom?s=3')

    def validate(self):
        if not QonForm.validate(self):
            return False
        
        # check all choices are unique
        seen = {}
        num_choices = int(self['numchoices']) + 1
        for i in range(1, num_choices):
            choice = self['choice%d' % i]
            
            if not choice:
                self.set_error('choice%d' % i, "required")
                return False

            choice = choice.lower().strip()
            if seen.has_key(choice):
                self.set_error('choice%d' % i, "Hmm, this choice looks like a duplicate of a previous choice.")
                return False
            seen[choice] = 1
        return True



class PollForm(QonForm):
    submit_button = 'submit-vote'
    cancel_button = 'cancel-vote'
    submit_buttons = [submit_button, cancel_button]
    
    def __init__(self, poll=None, user=None, no_vote=False):
        """Create polling form.
        
        no_vote is set to true to display form without submit buttons.
        """
        QonForm.__init__(self)
        self.poll = poll
        self.user = user
        self.no_vote = no_vote
        
        self.single_select = (self.poll.get_data().min_choice == 1) and \
            (self.poll.get_data().max_choice == 1)
        self.poll_choices = self.poll.get_data().choices[:]
        
        self._build_form()
    
    def _build_form(self):
        
        # get user's current choices
        user_choices = self.poll.user_vote_choices(self.user)
        
        value = None

        # first figure out if we need radio buttons or check boxes
        if self.single_select:
            if user_choices:
                value = user_choices[0]

            self.add_single_select('choices', title="Vote by choosing one item from this list:",
                options=self.poll_choices,
                value=value,
                required=True,
                )
        else:
            for i in range(1, len(self.poll_choices) + 1):
                self.add_checkbox('choice%d' % i, title=self.poll_choices[i-1],
                    value=self.poll_choices[i-1] in user_choices,
                    )
        
        if not self.no_vote:
            self.add_submit(self.cancel_button, value='Cancel')
            self.add_reset('reset', value="Reset")
            self.add_submit(self.submit_button, value='Submit Vote')
    
    def _checkboxes_to_choice_list(self):
        choices = []
        for i in range(1, len(self.poll_choices) + 1):
            if self['choice%d' % i]:
                choices.append(self.poll_choices[i-1])
        
        return choices
        
    def validate(self):
        if not QonForm.validate(self):
            return False
        
        if self.get_submit() != self.submit_button:
            return True
        
        if self.single_select:
            try:
                choices = self.poll.choice_list_to_choices(qon.util.coerce_to_list(self['choices']))
            except ValueError:
                self.set_error('choices', 'There was a problem with the selection of choices we received from your browser.')
                return False
        else:
            choices = self.poll.choice_list_to_choices(self._checkboxes_to_choice_list())
                            
        valid = self.poll.valid_vote(self.user, choices)
        if valid == 1:
            return True
            
        
        if self.single_select:
            error_field = 'choices'
        else:
            error_field = 'choice1'
            
        if valid == 0:
            self.set_error(error_field, 'Please verify you selected the required number of choices.')
            return False
        
        if valid == -1:
            self.set_error(error_field, "Sorry, you don't have permission to vote.")
            return False
        
        if valid == -2:
            self.set_error(error_field, "Sorry, you have already voted in this poll.")
            return False
        
        if valid == -3:
            self.set_error(error_field, "Sorry, your feedback score is not high enough to vote in this poll.")
            return False
            
        if valid == -4:
            self.set_error(error_field, "Sorry, you don't have enough points in your feedback bank to vote in this poll.")
            return False
        
        if valid == -5:
            self.set_error(error_field, "Sorry, you joined the site after this poll started.")
            return False
        
        return False
        
    def commit(self):
        if self.get_submit() == self.submit_button:
            if self.single_select:
                choices = self['choices']
            else:
                choices = self._checkboxes_to_choice_list()
            api.poll_vote(self.poll, self.user, choices)
            return get_request().redirect('./')
        else:
            return get_request().redirect('../')
            
    def render_field [html] (self, title, contents, hint, error, required=False):
        # custom render method to display multiple choice as vertically-aligned checkboxes
        from quixote.form2 import Form
        
        if self.single_select:
            # for single select revert to default rendering style
            return Form.render_field(self, title, contents, hint, error, required)
        
        d = {}
        d['contents'] = contents
        d['title'] = title
        d['error'] = ''
        d['hint'] = ''
        
        if error:
            d['error'] = self.render_error(error)
        if hint:
            d['hint'] = self.render_hint(hint)
        
        '''<tr>
        <th>&nbsp;&nbsp;</th>
        <th align="left">%(contents)s %(title)s</th>
        <th>%(error)s %(hint)s</th>
        </tr>
        ''' % d

class CancelItemForm(QonForm):

    submit_button = 'submit-cancel'
    submit_buttons = [submit_button]

    def __init__(self, poll):
        QonForm.__init__(self)
        self.poll = poll
        self._build_form()
        
    def _build_form(self):
        # add an extra input box for editor's comment
        if get_user() is not self.poll.creator:
            self.add_string('edit-comment', title="Editor's comment",
                required=True,
                size=70,
                hint="Enter a comment that will be displayed at the top of the poll's description.",
                )
        self.add_submit(self.submit_button, 'Cancel this poll')
        
    def _get_editors_note_template(self):
        return '''[**Canceled by group owner:** `%(editor)s`_ on %(date)s: %(comment)s]\n\n.. _`%(editor)s`: %(url)s'''
    
    def _get_editors_note(self):
        user = get_user()
        if user is not self.poll.creator:
            return self._get_editors_note_template() % \
                dict(editor=blocks.user.display_name_plain(user),
                    date=blocks.util.format_datetime_short(datetime.utcnow()),
                    url=messages.base_url[:-1] + blocks.user.path_to_user(user),
                    comment=self['edit-comment'])
        else:
            return '''[**Canceled by poll creator.**]'''

    def commit(self):
        if self.get_submit() == self.submit_button:
            api.poll_cancel(self.poll, self._get_editors_note())
        return get_request().redirect('./')
            
