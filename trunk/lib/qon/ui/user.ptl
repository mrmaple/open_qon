"""
$Id: user.ptl,v 1.171 2007/06/28 14:48:12 jimc Exp $

User-related UI: /user/
"""
__pychecker__ = "no-noeffect unusednames=request"

import sys, urllib, cStringIO
from datetime import datetime
from quixote import get_request, get_session_manager
from quixote.html import href
from quixote.form2 import StringWidget, PasswordWidget, TextWidget
from quixote.errors import AccessError, TraversalError
from dulcinea.database import unpack_oid, pack_oid

from qon import api, blog, atom
from qon.util import sort_list, format_ago, get_page_template, standardize_lon_lat_coord, standardize_url, get_oid
from qon.base import get_user, get_user_database, get_group_database, get_list_database, get_connection, get_tagged_item_database, get_tags_database
from qon import local
from qon.user import HasEmail
from qon.ui import blocks
from qon.ui.form import QonForm, manage_form, manage_form_in_page
from qon.ui.message import MessageUI
from qon.ui.base import QonBaseUI
from qon.ui.blocks.wiki import rst_to_html
import qon.karma

from qon.ui import messages
_ = messages.t
def _h(x): return htmltext(_(x))

_num_to_show_in_summary = 25

_q_exports = ['new', 'newpass', 'signout']

def _people_home_tabs [html] (request):
    tabs = [
        {
            'name': 'Active',
            'path': '/user/',
            'accesskey': 'p',
            'class': 'plain',
        },
        {
            'name': 'Tagged',
            'path': '/user/tagged/',
            'accesskey': 'g',
            'class': 'plain',
        },
        {
            'name': 'Top Rated',
            'path': '/user/top/',
            'accesskey': 't',
            'class': 'plain',
        },
        {
            'name': 'Largest Banks',
            'path': '/user/banks/',
            'accesskey': 'b',
            'class': 'plain',
        },
        {
            'name': 'Feedback Given Away',
            'path': '/user/feedbackgiven/',
            'accesskey': 'f',
            'class': 'plain',
        },         
        ]
    if get_user():
        tabs.insert(4,
            {
            'name': 'Near Me',
            'path': '/user/nearme/',
            'accesskey': 'n',
            'class': 'plain',
            })          
    '''
    <h1>People</h1>
    '''
    
    blocks.util.section_tabs(request, tabs,
        getattr(request, str('qon_section_mode'), ''))


def user_profile_tabs [html] (request):

    user_id = request.profiled_user.get_user_id()
    
    tabs = [
        {
            'name': 'Profile',
            'path': '/user/%s/' % user_id,
            'accesskey': 'h',
            'class': 'plain',
        },
        {
            'name': 'Tags',
            'path': '/user/%s/tags/' % user_id,
            'accesskey': 't',
            'class': 'plain',
        },
        {
            'name': 'News',
            'path': '/user/%s/news/' % user_id,
            'accesskey': 'n',
            'class': 'plain',
        },
        {
            'name': 'Discussions',
            'path': '/user/%s/threads/' % user_id,
            'accesskey': 'd',
            'class': 'plain',
        },        
        ]

    if get_user() == request.profiled_user:
        tabs.extend((
        {
            'name': 'Inbox',
            'path': '/user/%s/msg/' % user_id,
            'accesskey': 'i',
            'class': 'plain',
        },
        {
            'name': 'Trash',
            'path': '/user/%s/msg/trash' % user_id,
            'accesskey': 't',
            'class': 'plain',
        },
        {
            'name': 'Settings',
            'path': '/user/%s/private/' % user_id,
            'accesskey': 's',
            'class': 'plain',
        },        
        ))
    
    '''<h1>%s</h1>''' % blocks.util.display_name(request.profiled_user)
    
    blocks.util.section_tabs(request, tabs,
        getattr(request, str('qon_section_mode'), ''))    

def user_contributions (user):
    """Return user's recent activity: (blog_items, pnews)"""
    
    cur_user = get_user()
    
    # get user activity data
    activity = user.get_activity()
    
    # gather blog items
    blog_items = [(date, 'blogitem', i, None) for date, i in \
        activity.recent_blog_items_for_reader(cur_user)]
    
    # gather blog comments
    blog_items.extend([(date, 'blogcomment', i, parent) for date, i, parent in \
        activity.recent_blog_comments_for_reader(cur_user)])
        
    # gather comments on personal news
    blog_items.extend([(date, 'blogcomment', i, parent) for date, i, parent in \
        activity.recent_personal_comments_for_reader(cur_user)])
        
    # gather personal news items
    pnews = [(i.date, 'blogitem', i, None) for date, i in \
        activity.recent_personal_news_for_reader(cur_user)]

    return blog_items, pnews

def _q_access(request):
    # hook in here to add global menu for user/
    blocks.util.set_global_mode(request, 'People')
    blocks.util.set_section_tabs(request, _people_home_tabs)
    blocks.util.set_help_block(request, 'People')

    menus = []
    blocks.util.set_menus(request, menus)  

def _q_lookup(request, name):
    if name == 'active':
        return ActiveUI(request, name)    
    if name == 'tagged':
        return TaggedUI(request, name)    
    if name == 'top':
        return TopRatedUI(request, name)
    elif name == 'banks':
        return LargestBanksUI(request, name)
    elif name == 'feedbackgiven':
        return FeedbackGivenAwayUI(request, name)
    elif name == 'nearme':
        return NearMeUI(request, name)       
    return UserUI(request, name)    
        
def _q_index (request):
    # Alex removed [html] from this function's signature
    return request.redirect('./active/')        # this way, when we're in the active sub-tab, we'll know for sure what our URL is
    # return ActiveUI(request)._q_index(request)  # this determines the default subtab
        
def get_crumb():
    return "People"

def signout(request):
    request.session.user = None
    get_session_manager().expire_session(request)
    request.response.expire_cookie('footprints', path='/')
    request.response.expire_cookie('aux1', path='/')
    return request.redirect("/home/")
    
def _render_form [html] (request, title, form, heading_text='', 
        template_text='', suppress_login=False):
    # renders a form using an optional template. if template_text is not empty,
    # it must include a %(form)s variable as a placeholder for the form.


    blocks.util.header(request, title, suppress_login=suppress_login)
    '<h1>%s</h1>' % title
    heading_text

    form_out = form.render()

    if template_text:
        # embed form into template
        try:
            template_text % dict(form=form_out)
        except (TypeError, KeyError):
            # some string placeholders not provided, template invalid
            # therefore, render form only
            form_out
    
    else:
        form_out

    blocks.util.footer(title)
    
def new [html] (request):    
    title = "New user: sign up here"
    
    form = NewUserForm(request)

    if not form.validate():      
        
        # try to fetch template
        template_text = get_page_template('user_new', format='html')
        h = ''
        if not template_text:
            # otherwise use some simple text
            template_text = ''
            h = '''<p>Signing up with %s is easy. Just enter your email address
            (twice for verification), and we'll email you your password.</p>''' % messages.site_title

        return _render_form(request, title, form, heading_text=h, 
            template_text=template_text, suppress_login=True)
            
    (email, message) = form.commit()

    blocks.util.header(request, "New user: check your email", suppress_login=False)
    '<p>Your account has been created and your password has been emailed to %s.</p>' % email
    
    # give them a place to enter their password right here.
    # do we need to ensure that it's a https connection before the login?
    # we don't want a plain-text login if we can help it.
    '''<p>
    The easiest way to continue the join process is to click on the link in the e-mail that
    we just sent to you.  As an alternative, you can copy and paste the password in the e-mail
    into the password field below.
    </p>
    <p>
    <form method="post" action="/home/">
     <input type="hidden" name="email" value="%s">
     Please paste the password that we sent: 
     <input type="password" name="password">
     <input name="submit-login" value="Sign in" type="submit">
    </form>
    </p>
    ''' % (email)

    if local.SUPPRESS_EMAIL:
        '<hr />'
        '<pre>'
        message
        '</pre>'
    blocks.util.footer(title, additional_omniture_variables=dict(s_events='event1'))
    
def newpass [html] (request):   
    title = "Existing user: request new password"
    
    form = NewPasswordForm(request)

    if not form.validate():
        return _render_form(request, title, form, suppress_login=True)

    (email, message) = form.commit()

    blocks.util.header(request, "New password: check your email", suppress_login=1)
    '<p>A new password was generated and sent to %s.</p>' % (email)

    if local.SUPPRESS_EMAIL:
        '<hr />'
        '<pre>'
        message
        '</pre>'
    blocks.util.footer(title)


    
class UserUI(QonBaseUI):
    _q_exports = ['feedback', '_f_p', '_f_n', 'text', 'feedbacklist', 'groupownerlist',
        'groupmemberlist', 'negfeedbacklist', 'neg_given', 'pos_given', '_staff', '_ignore', '_dont_ignore']

    def __init__(self, request, name):
        self.user = get_user_database().get_user(name)
        if not self.user:
            raise TraversalError

        request.profiled_user = self.user   # for tabs
        self.path = blocks.user.path_to_user(self.user)
            
        if self.user == get_user():
            menus = []

        else:
            menus = [
                {
                    'name': 'Send a message to this user',
                    'path': 'msg/new',
                    'title': 'Send a new message to this user using the internal messaging system',
                    'disabled': self.user.is_admin(),
                },
                ]
            
            # add staff menu item
            cur_user = get_user()
            if cur_user and cur_user.is_staff():
                menus.append({
                    'name': 'Staff',
                    'path': '_staff',
                    'title': 'Access staff options',
                    })
            
        blocks.util.set_global_mode(request, 'People')
        request.qon_message_user = self.user
        blocks.util.set_section_tabs(request, user_profile_tabs)
        blocks.util.set_section_mode(request, 'Profile')

        blocks.util.set_menus(request,menus)
        blocks.util.set_help_block(request, 'User Page')
        
            
    def _q_access(self, request):
        # when handling /user/{username}/etc... {username} must be valid
        
        if self.user is None:
            raise TraversalError
        
        # unless we're headed to 'news/rss', you must be signed in
        # disabled this code to allow anon access to user profiles and
        # personal news
        
        #url = request.get_url()
        #if url[url.rfind('/'):] != '/rss':
        #    if not get_user():
        #        raise AccessError
            
    def _q_lookup(self, request, name):
        # handles /user/{username}/etc...
        if name == 'private':
            return UserPrivateUI(request, self.user)
        elif name == 'msg':
            return MessageUI(request, self.user)
        elif name == 'tags':
            blocks.util.set_section_mode(request, 'User tags')
            blocks.util.set_section_mode(request, 'Tags')
            return UserTagsUI(request, self.user)
        elif name == 'news':
            from qon.ui.blog import BlogUI
            return BlogUI(request, self.user)
        elif name == 'staff':
            return UserStaffUI(request, self.user)
        elif name == 'threads':
            return UserThreadsUI(request, self.user)
        elif name == 'email':
            return blocks.action.email_this_page(request, self.user)
        else:
            # a little help for short URL references to wiki pages
            from quixote.util import Redirector
            from qon.ui.blocks.wiki import path_to_wiki
            return Redirector(path_to_wiki(self.user.get_wiki()) + '%s/' % name)
        return None
            
    def _q_index [html] (self, request):
        # handles /user/{username}/

        # cookie this page
        blocks.util.cookie_this_page(self.user)

        # declare this as emailable
        blocks.util.set_emailable_item(request, self.user)
        
        cur_user = get_user()
        
        self._user_heading(request)
        
        # only show user profile to a signed in user if this user
        # is below the content threshold
        if cur_user or self.user.can_post():
            blocks.user.about(self.user)
        else:
            '''
            <div class="indent">
            <p><em>User profile folded due to low feedback score. Sign in to view profile.</em></p>
            </div>
            '''
        
        if self.user.can_read(cur_user):
            # suppress content for anon users
            self._user_contributions()
                    
        blocks.util.footer()

    def _user_heading [html] (self, request):
        cur_user = get_user()
        title = '%s: %s' % (messages.site_title, blocks.user.display_name_plain(self.user))
        blocks.util.header(request, title)
        "<h1>%s</h1>" % blocks.user.display_name(self.user, show_private = (cur_user is self.user),
            )
        '<p class="subtitle">'
        blocks.user.karma(self.user, show_control=0)
        if self.user.can_get_karma_from(cur_user):
            ' (give <a href="feedback">feedback</a>)'
        '<br />'
        
        # XXX remove if statement to roll out to all users
        if request.get_form_var('show_standing'):
            blocks.user.karma_standing(self.user)
            '<br />'
        
        blocks.user.karma_given(self.user)
        '<br />'
        blocks.user.karma_comments(self.user)
        '<br />'

        blocks.user.karma_tags(self.user)
        '<br />'
        
        if not self.user.is_admin():
            if cur_user:
                # suppress shrouded email (which includes domain) for anon users
                blocks.user.shrouded_email(self.user)
                '<br />'

        blocks.user.member_since(self.user)
        '<br />'
        blocks.user.last_login(self.user)
        '<br />'
        blocks.user.idle(self.user)
        
        if cur_user:
            # suppress detailed content for anon users
            '<br />'
            blocks.group.owner(self.user)
            '<br />'
            blocks.group.member(self.user)
            '<br />'
            blocks.user.karma_people(self.user)
            '<br />'
            blocks.user.karma_negative_people(self.user)
            if self.user.location and len(self.user.location.strip()) > 0:
                '<br />'
                blocks.user.location(self.user)
            if self.user.latitude is not None and self.user.longitude is not None:
                '<br />'
                blocks.user.latitude_longitude(self.user)
                if cur_user.latitude is not None and cur_user.longitude is not None and self.user is not cur_user:
                    '<br />'
                    blocks.user.distance_from_me(self.user, cur_user)                
            blocks.user.external_links(self.user)   # delicious, flickr, skype and external blogs
        '</p>'
        
    def _user_contributions [html] (self):

        # it's recommended that _list_cap be set equal or lower than UserActivity._recent_count,
        #  so that the combined lists won't have chronological "gaps"
        _list_cap = 50
            
        cur_user = get_user()
        
        # get user activity data
        activity = self.user.get_activity()
        
        # get blog and personal news activity
        blog_items, pnews = user_contributions(self.user)
        
        # cap personal news to 10, since the list is called "latest personal news"
        pnews = pnews[:10]

        # sort blog items and comments
        blog_items.sort()
        blog_items = blog_items[-_list_cap:]   # cap to latest 50
        blog_items.reverse()
                
        # generate HTML for blog items
        bcells = []
        for i in blog_items:
            date, xtype, item, parent = i
            if xtype == 'blogitem':
                bcells.append(blocks.blog.format_item_title(item))
            elif xtype == 'blogcomment':
                bcells.append(blocks.blog.format_comment_title(item, parent))
        
        # gather wiki pages and comments
        pages = []
        pages.extend([(date, 'wikipage', p, p)
            for date, p in activity.recent_wiki_pages_for_reader(cur_user)])
        pages.extend([(c.date, 'wikicomment', c, p)
            for date, c, p in activity.recent_wiki_comments_for_reader(cur_user)])
        
        # sort wiki pages and comments
        pages.sort()
        pages = pages[-_list_cap:]   # cap to latest 50           
        pages.reverse()
        pcells = []
        
        # generate HTML for wiki pages and comments
        for i in pages:
            date, xtype, item, page = i
            if xtype == 'wikipage':
                pcells.append(blocks.wiki.format_page_title(item))
            elif xtype == 'wikicomment':
                pcells.append('Comment on ' + blocks.wiki.format_page_title(page))
        
        # output table
        '''<table>
        <tr>
            <td colspan="2">
            '''+blocks.util.format_table(1,
                [blocks.blog.format_item_title(i) for date, xtype, i, parent in pnews],
                headings=[href('news/','Latest personal news')],
                )+ '''
            </td>
        </tr>
        <tr>
            <td>
            '''+blocks.util.format_table(1,
                bcells,
                headings=['Recent discussion posts and comments'],
                ) + '''
            </td>
            
            <td>
            '''+blocks.util.format_table(1,
                pcells,
                headings=['Recent workspace edits'],
                ) + '''
            </td>
        </tr>
        </table>
        
        <p>View my <a href="threads/">active discussions.</a></p>
        '''
        
        if not cur_user:
            '''
            <p class="alert">Because you are not signed in, only publicly-available
            contributions are being displayed on this page.</p>
            '''

    def text [plain] (self, request):
        request.response.set_content_type('text/plain')
        self.user.bio
        
    def _staff [html] (self, request):
        cur_user = get_user()
        if not cur_user or not cur_user.is_staff():
            raise AccessError
    
        title = 'Staff Access for User %s' % blocks.user.display_name_plain(self.user)
        blocks.util.header(request, title)
        '''<h1>%s</h1>''' % title
        '''
        <ul>
        <li><a href="./negfeedbacklist?staff=1">List of users who have given this user negative feedback</a></li>
        <li><a href="./feedbacklist?staff=1">List of users who have given this user positive feedback</a></li>
        <li><a href="./neg_given?staff=1">List of negative feedback targets</a></li>
        <li><a href="./pos_given?staff=1">List of positive feedback targets</a></li>
        </ul>
        <ul>
        <li><a href="./private/">Settings page for this user</a></li>
        <li><a href="/admin%s">Admin page for this user</a></li>
        </ul>
        ''' % self.path
        blocks.util.footer()
    
    def _format_karma_giver_rows(self, karma_givers, hide_under_thresh=False):
        user_db = get_user_database()
        rows = []
        for karma, user_id in karma_givers:
            if abs(karma) >= abs(qon.karma.show_neg_threshold):
                rows.append((blocks.user.display_name(user_db.get_user(user_id)),
                    karma))
            else:
                if not hide_under_thresh:
                    rows.append((blocks.user.display_name(user_db.get_user(user_id)),
                        ' '))
        return rows

    def feedbacklist [html] (self, request):
        if not get_user():
            raise AccessError
        
        user_db = get_user_database()
        staff_access = request.get_form_var('staff')

        title = messages.site_title + ': Feedback for %s' % blocks.user.display_name_plain(self.user)
        blocks.util.header(request, title)
        '''<h1>Positive feedback for %s</h1>''' % blocks.user.display_name(self.user)
        '''<p class="formHelp">
        The following users have given positive feedback to %s. They are listed in decreasing
        order, with the most feedback having been given by the first user(s) listed. The actual
        number of feedback points given by each user is confidential, unless it is 5 or more points.
        </p>
        ''' % blocks.user.display_name_plain(self.user)
        
        karma_givers = self.user.positive_karma_givers()

        '''<p>
        Number of people giving positive feedback: %d.<br />
        Total number of positive feedback points: %d.
        </p>''' % (len(karma_givers), self.user.karma_plus_received())

        if staff_access and get_user().is_staff() and get_user() is not self.user:
            '''<p><span class="alert">Confidential Staff Information Only!</span>
            All positive feedback givers are listed below. This information is <strong>not</strong>
            to be disclosed to members!
            </p>
            '''
            rows = []
            for karma, user_id in karma_givers:
                rows.append((blocks.user.display_name(user_db.get_user(user_id)),
                    karma))
            blocks.util.format_table_rows(rows, headings=['Positive Feedback From', 'Amount'])
        else:
            # expose +5 karma givers
            rows = self._format_karma_giver_rows(karma_givers)
            blocks.util.format_table_rows(rows, headings=['Positive Feedback From', 'Amount'])
        
        blocks.util.footer()
        
    def neg_given [html] (self, request):
        if not get_user():
            raise AccessError
            
        staff_access = request.get_form_var('staff')
        if staff_access and not get_user().is_staff():
            raise AccessError
        
        if not staff_access and get_user() is not self.user:
            raise AccessError

        title = messages.site_title + ': Negative Feedback Given by %s' % blocks.user.display_name_plain(self.user)
        blocks.util.header(request, title)
        '''<h1>Negative feedback given by %s</h1>''' % blocks.user.display_name(self.user)
        '''<p class="formHelp">
        You have given the following users negative feedback.
        </p>
        '''
        
        if staff_access and get_user() is not self.user:
            '''<p><span class="alert">Confidential Staff Information Only!</span>
            Targets of negative feedback by this user are listed below. This information is <strong>not</strong>
            to be disclosed to members!
            </p>
            '''
        
        users = self.user.karma_minus_given_to()
        
        '''<p>
        Number of people I've given negative feedback to: %d.<br />
        Total number of negative feedback points given: %d.
        </p>''' % (len(users), self.user.karma_minus_given())
        
        rows = []
        for u in users:
            rows.append((blocks.user.display_name(u), blocks.user.karma(u, show_title=0, show_control=0, acting_user=self.user)))
        
        blocks.util.format_table_rows(rows, headings=['Negative Feedback Given To', 'Feedback'])
        
        blocks.util.footer()
        
    def pos_given [html] (self, request):
        if not get_user():
            raise AccessError
            
        staff_access = request.get_form_var('staff')
        if staff_access and not get_user().is_staff():
            raise AccessError
        
        if not staff_access and get_user() is not self.user:
            raise AccessError

        title = messages.site_title + ': Positive Feedback Given by %s' % blocks.user.display_name_plain(self.user)
        blocks.util.header(request, title)
        '''<h1>Positive feedback given by %s</h1>''' % blocks.user.display_name(self.user)
        '''<p class="formHelp">
        You have given the following users positive feedback.
        </p>
        '''
        
        if staff_access and get_user() is not self.user:
            '''<p><span class="alert">Confidential Staff Information Only!</span>
            Targets of positive feedback by this user are listed below. This information is <strong>not</strong>
            to be disclosed to members!
            </p>
            '''
        
        users = self.user.karma_plus_given_to()
        
        '''<p>
        Number of people I've given positive feedback to: %d.<br />
        Total number of positive feedback points given: %d.
        </p>''' % (len(users), self.user.karma_plus_given())
        
        rows = []
        for u in users:
            rows.append((blocks.user.display_name(u), blocks.user.karma(u, show_title=0, show_control=0, acting_user=self.user)))
        
        blocks.util.format_table_rows(rows, headings=['Positive Feedback Given To', 'Feedback'])
        
        blocks.util.footer()
        
    def negfeedbacklist [html] (self, request):
        if not get_user():
            raise AccessError
            
        user_db = get_user_database()
        staff_access = request.get_form_var('staff')
        
        title = messages.site_title + ': Negative Feedback for %s' % blocks.user.display_name_plain(self.user)
        blocks.util.header(request, title)
        '''<h1>Negative feedback for %s</h1>''' % blocks.user.display_name(self.user)
        '''<p class="formHelp">
        The following users have given <strong>more than five points</strong> of negative feedback to %s. They are listed in decreasing
        order, with the most negative feedback having been given by the first user(s) listed. The actual
        number of feedback points given by each user is confidential, unless it is 5 or more points.
        </p>
        ''' % blocks.user.display_name_plain(self.user)
        
        karma_givers = self.user.negative_karma_givers()
        display_givers = [user_id for karma, user_id in karma_givers if karma <= qon.karma.show_neg_threshold]
        
        '''<p>
        Number of people giving negative feedback: %d.<br />
        Total number of negative feedback points: %d.
        </p>''' % (len(karma_givers), self.user.karma_minus_received())
        
        if staff_access and get_user().is_staff() and get_user() is not self.user:
            '''<p><span class="alert">Confidential Staff Information Only!</span>
            All negative feedback givers are listed below. This information is <strong>not</strong>
            to be disclosed to members!
            </p>
            '''
            rows = []
            for karma, user_id in karma_givers:
                rows.append((blocks.user.display_name(user_db.get_user(user_id)),
                    karma))
            blocks.util.format_table_rows(rows, headings=['Negative Feedback From', 'Amount'])
        else:
            # expose +5 karma givers
            rows = self._format_karma_giver_rows(karma_givers, hide_under_thresh=True)
            blocks.util.format_table_rows(rows, headings=['Negative Feedback From', 'Amount'])
        
        blocks.util.footer()
        
    def groupownerlist [html] (self, request):
        groups = get_group_database().owned_groups(self.user)
        dn = blocks.user.display_name_plain(self.user)
        
        self._group_list(request, groups,
            title = 'Groups owned by %s' % dn,
            heading_title = 'Groups owned by %s' % blocks.user.display_name(self.user),
            help_text = 'The following groups are owned by %s.' % dn,
            heading_text = '''
                <p>
                Number of groups owned: %d.
                </p>
                '''% len(groups),
            )
    
    def groupmemberlist [html] (self, request):
        groups = get_group_database().member_groups(self.user)
        dn = blocks.user.display_name_plain(self.user)
        
        self._group_list(request, groups,
            title = 'Groups %s is a member of' % dn,
            heading_title = 'Groups %s is a member of' % blocks.user.display_name(self.user),
            help_text = '%s has joined the following groups.' % dn,
            heading_text = '''
                <p>
                Number of groups: %d.
                </p>
                '''% len(groups),
            )
    
    def _group_list [html] (self, request, groups, title='', heading_title='', help_text='', heading_text=''):
        if not get_user():
            raise AccessError
            
        page_title = messages.site_title + ': %s' % (title)
        blocks.util.header(request, page_title)
        '''<h1>%s</h1>''' % (heading_title)
        '''<p class="formHelp">%s</p>''' % help_text
        
        heading_text
                        
        blocks.group.list_table(groups, title=title)
        
        blocks.util.footer()
        
    def get_crumb(self):
        return blocks.user.display_name(self.user)
        
    def _f_p (self, request):
        user = get_user()
        if not user:
            raise AccessError
        api.karma_give_good(user, self.user)
        return request.redirect('./?e=ufp')
        
    def _f_n (self, request):
        user = get_user()
        if not user:
            raise AccessError
        
        # check for over-neg and redirect to full-page feedback
        if self.user.karma_points_from(user) <= qon.karma.show_neg_threshold + 1:
            return request.redirect('./feedback')
        
        api.karma_give_bad(user, self.user)
        return request.redirect('./?e=ufn')

    def feedback [html] (self, request):
    
        # trying to access feedback page for self redirects to profile page
        if not self.user.can_get_karma_from(get_user()):
            return request.redirect(str('./'))
            
        blocks.action.karma_page(self.user, blocks.user.display_name(self.user))

    def _ignore [html] (self, request):
        user = get_user()
        if not user:
            raise AccessError
        user.ignore_user(self.user.get_user_id())
        return request.redirect(str('./'))

    def _dont_ignore [html] (self, request):
        user = get_user()
        if not user:
            raise AccessError
        user.dont_ignore_user(self.user.get_user_id())
        return request.redirect(str('./'))

class UserTagsUI(QonBaseUI):
    _q_exports = ['_tag', '_f_p', '_f_n', '_feedbacklist']
    # , 'feedbacklist', 'negfeedbacklist', 'neg_given', 'pos_given', 'feedback']

    def __init__(self, request, user):
        self.user = user
        if not self.user:
            raise AccessError

        blocks.util.set_menus(request,[])
        #blocks.util.set_section_mode(request, 'User tags')
        #blocks.util.set_section_mode(request, 'Tags')

    def get_crumb(self):
        return "User tags"

    def _q_index [html] (self, request):
        user = self.user
        blocks.util.set_menu_mode(request, './')
        #blocks.util.set_section_mode(request, 'Tags')
        user_name = user.contact_name
        title = "ned.com: Personal Tags"
        blocks.util.header(request, title)
        '''
        <h1>Tags describing %(user)s</h1>
        <p class="formHelp">
        Displays the tags that have been applied to %(user)s by other members.  Click on a tag
        to see all members who share the tag.
        </p>
        ''' % {"user": user_name}

        # show a tag cloud from the user_db HasTags cloud
        tidb = get_tagged_item_database()
        tags_n_counts = tidb.get_tags_n_counts(user._p_oid)
        if tags_n_counts:
            '<br />'
            if 0: #len(tags_n_counts) < 5:
                '<span class="title">Tags:&nbsp;&nbsp;</span>' 
                qon.ui.blocks.tags.cloud(tags_n_counts, None, "/user/tagged/", mini_cloud=True)
                '<br />'
            else:
                qon.ui.blocks.tags.cloud(tags_n_counts, None, "/user/tagged/", mini_cloud=False)
            #
        # 
        else:
            '<br />'
            'No tags have been applied yet.'
            '<br />'
        #

        # show current_and_new to allow tagging
        '<br />'
        if get_user():
            qon.ui.blocks.tags.edit_and_current(user, in_place=False)

        '''
        <h1>Tags applied by %(user)s</h1>
        <p class="formHelp">
        Displays the tags that %(user)s has applied to items site-wide.
        </p>
        ''' % {"user": user_name}
        tags_n_counts = user.get_tags_n_counts()
        #"%i tags<br />" % len(tags_n_counts)

        '<p class="subtitle"><span class="title">'
        #blocks.tags.karma(user, './feedback', show_control=False)

        blocks.user.tagging_karma(user, './', show_stars=1, show_feedbacklist=1)

        #if user.can_get_karma_from(get_user()):
            #' (give <a href="feedback">feedback</a>)'
        '</span></p>'


        if tags_n_counts:
            blocks.tags.cloud(tags_n_counts, user, './')
        else:
            "%s hasn't applied any tags yet." % user_name

        # show a list of all items tagged by this user, in 
        # reverse-chronological order
        if tags_n_counts:
            '''
            <h1>Tagged content</h1>
            <p class="formHelp">
            The items that %s has applied tags to; most recently tagged items appear first.
            </p><br />
            ''' % user_name
            # we need (date, item, tags)  for every tagged item
            tidb = get_tagged_item_database()
            items_tagged = []
            items = user.get_tagged_items()
            user_id = user.get_user_id()
            for item_oid in items:
                ta = tidb.get_tag_attributes(item_oid, user_id)
                date = ta.date_modified
                if ta.tags:
                    items_tagged.append( (date, item_oid, ta.tags) )
    
            items_tagged.sort()
            items_tagged.reverse()
    
            # display the items
            # 
            for date, item_oid, tags in items_tagged:
                item = get_oid(item_oid)
                desc = qon.ui.blocks.util.fancy_one_line_display (item, dont_bold = False, alt_href=None)
                '<dt>'
                desc
                '</dt>'
                '<dd>'
                '<span class="discreet">'
                'Tagged %s with <span style="color:#404040">%s</span>' % (format_ago(date), ", ".join(tags))
                '</span>'
                '</dd>'
                '<br />'
            #
        # if tags_n_counts

        blocks.util.footer()

    def _q_lookup(self, request, component):
        return self.tag_results(request, component)

    def _tag [plain] (self, request):
        user = get_user()
        group = None
        item_oid_text = request.get_form_var('item_oid')
        item_oid = pack_oid(long(item_oid_text))
        tags_line = request.get_form_var('tags')

        #"tagging %s with %s" % (item_oid_text, tags)
        qon.api.tag_item(tags_line, user, item_oid, group, None, is_user=True)

        # re-index this user, because the search can find them by tag
        qon.search.searchengine.notify_edited_user(self.user)

        format = request.get_form_var('format')
        if format and format == 'json':
            result_tags = " ".join(qon.tags.standardize_tags(tags_line))
            """{ "result" : "success",
            "newtags": "%s",
            "item_oid" : "%s"
            }""" % (result_tags, item_oid_text)
        else:
            # redirect back to the tags page
            return request.redirect('.')
        #
    #

    def new_tag_results [html](self, request, component):
        tags = component.split(str(','))
        tags_str = ', '.join(tags)
        tags_db = get_tags_database()

        title = "Personal Tag Results for %s" % tags_str

        blocks.util.header(request, "ned.com: %s" % title)
        user = get_user()
        '<h2>%s</h2>' % title
        'Expand results to show <A HREF="/home/tags/%s">items tagged by anyone</A><br />' % component
        '<br />'

        item_oids = get_tags_database().get_tagged_items(tags)
        if item_oids:
            '<TABLE><TR><TD WIDTH="90%">'
            qon.ui.blocks.tags.tagged_items_table(item_oids, tags, public_items=False)
            '</TD>'
            '<TD>'

            # find related tags
            tags_n_counts = tags_db.get_related_tags_n_counts(tags)
            related_tags = [tag for tag, count in tags_n_counts]
            related_link = "../tags/%s," % ",".join(tags)
            if tags_n_counts and len(item_oids) > 1:
                'Narrow&nbsp;your&nbsp;results: '
                qon.ui.blocks.tags.cloud(tags_n_counts,tags_db, related_link, mini_cloud=True)
            #
            '</TD></TR></TABLE>'

            if len(tags) > 1:
                all_tags = tags + related_tags
            else:
                # the one current tag would just link back to this page
                all_tags = related_tags

            if len(all_tags) > 1:
                links = ['<A HREF="../tags/%s">%s</A>' % (tag,tag) for tag in all_tags]
                'See everything tagged with: %s <br />' %  ", ".join(links)
            #
        else:
            "Nothing has been tagged with %s yet" % tags_str

        blocks.util.footer()
    #

    def tag_results [html](self, request, component):
        tags = component.split(str(','))
        tags_str = ', '.join(tags)
        tags_db = get_tags_database()

        title = "Personal Tag Results for %s" % tags_str

        blocks.util.header(request, "ned.com: %s" % title)
        user = get_user()
        '<h2>%s</h2>' % title
        'Expand results to show <A HREF="/home/tags/%s">items tagged by anyone</A><br />' % component
        '<br />'

        item_oids = get_tags_database().get_tagged_items(tags)
        if item_oids:
            '<TABLE><TR><TD WIDTH="90%">'
            qon.ui.blocks.tags.tagged_items_table(item_oids, tags, public_items=False)
            '</TD>'
            '<TD>'

            # find related tags
            tags_n_counts = tags_db.get_related_tags_n_counts(tags)
            related_tags = [tag for tag, count in tags_n_counts]
            related_link = "../tags/%s," % ",".join(tags)
            if tags_n_counts and len(item_oids) > 1:
                'Narrow&nbsp;your&nbsp;results: '
                qon.ui.blocks.tags.cloud(tags_n_counts,tags_db, related_link, mini_cloud=True)
            #
            '</TD></TR></TABLE>'

            if len(tags) > 1:
                all_tags = tags + related_tags
            else:
                # the one current tag would just link back to this page
                all_tags = related_tags

            if len(all_tags) > 1:
                links = ['<A HREF="../tags/%s">%s</A>' % (tag,tag) for tag in all_tags]
                'See everything tagged with: %s <br />' %  ", ".join(links)
            #
        else:
            "Nothing has been tagged with %s yet" % tags_str

        blocks.util.footer()
    #

    def _format_karma_giver_rows(self, karma_givers, hide_under_thresh=False):
        user_db = get_user_database()
        rows = []
        for karma, user_id in karma_givers:
            if abs(karma) >= abs(qon.karma.show_neg_threshold):
                rows.append((blocks.user.display_name(user_db.get_user(user_id)), karma))
            else:
                if not hide_under_thresh:
                    rows.append((blocks.user.display_name(user_db.get_user(user_id)), ' '))
        return rows

    def _feedbacklist [html] (self, request):
        # must pass path_to_item for comments - others can pass None
        user_name = self.user.contact_name

        _rollout_date = datetime(2005, 2, 10, 0)    # utc
        _rollout_date_display = "February 9, 2005, 4:00PM PST"

        item = self.user.tag_karma
        staff_access = request.get_form_var('staff')
        user_db = get_user_database()

        assert isinstance(item, qon.karma.HasKarma)

        def make_rows(karma_givers, show_all=False):
            rows = []
            for karma, user_id in karma_givers:
                if abs(karma) >= abs(qon.karma.show_neg_threshold):
                    rows.append((blocks.user.display_name(user_db.get_user(user_id)),
                        karma))
                else:
                    if show_all:
                        rows.append((blocks.user.display_name(user_db.get_user(user_id)),
                            ' '))
            return rows

        def user_tables [html] ():
            # positive feedback
            rows = make_rows(pos_karma_givers, show_all=staff_access)
            blocks.util.format_table_rows(rows, headings=['Significant Positive Feedback From', 'Amount'])

            # negative feedback
            rows = make_rows(neg_karma_givers, show_all=staff_access)
            blocks.util.format_table_rows(rows, headings=['Significant Negative Feedback From', 'Amount'])


        # don't let anon users like crawlers see this
        if not get_user():
            raise AccessError

        title = 'Feedback for %s\'s tags' % user_name
        blocks.util.header(request, title)
        '''<h1>%s</h1>''' % title
        '''<p class="formHelp">
        The following users have given more than 5 positive feedback points or more than
        5 negative feedback points to this item. They are listed in decreasing
        order, with the most feedback having been given by the first user(s) listed.
        </p>
        '''

        # get all the info
        plus_total, neg_total, pos_karma_givers, neg_karma_givers = item.karma_details()

        '''<p class="subtitle">'''
        blocks.user.tagging_karma(self.user, './', show_stars=1)
        '''<br />
        <span class="title"><span class="info">Positive</span> feedback received:</span> %d users, %d points.<br />
        <span class="title"><span class="alert">Negative</span> feedback received:</span> %d users, %d points.<br />
        </p>''' % (len(pos_karma_givers), plus_total,
            len(neg_karma_givers), neg_total )

        user_tables()

        blocks.util.footer()
    #

    def _f_p (self, request):
        user = get_user()
        if not user:
            raise AccessError
        # no e-mail is sent, since message defaults to None
        api.tag_karma_give_good(user, self.user)
        return request.redirect('./?e=ufp')

    def _f_n (self, request):
        user = get_user()
        if not user:
            raise AccessError

        # no e-mail is sent, since message defaults to None
        api.tag_karma_give_bad(user, self.user)

        # check for over-neg and redirect to full-page feedback
        #if self.user.tag_karma.karma_points_from(user) <= qon.karma.show_neg_threshold + 1:
        #    return request.redirect('./_feedbacklist')

        return request.redirect('./?e=ufn')
    #
#

class UserStaffUI(QonBaseUI):

    _q_exports = ['inval_session']
    
    def __init__(self, request, user):
        self.user = user
        blocks.util.set_menu_mode(request, 'staff/')
        blocks.util.prefix_menu_paths(request, '../')
    
    def _q_access(self, request):
        if self.user is None:
            raise TraversalError
        
        if get_user() is None:
            raise AccessError
        
        if not get_user().is_staff():
            raise AccessError
    
    def _q_index [html] (self, request):
        # handles /user/{username}/staff/
        
        title = messages.site_title + ': User Staff Access'
        blocks.util.header(request, title)
        
        '<h2>%s</h2>' % title
        options = [
            ('inval_session', "Invalidate user's session"),
            ]
        blocks.util.navigation(options, 'Select one:')

        blocks.util.footer()
        
    def inval_session(self, request):
        from qon.base import get_session_manager
        smgr = get_session_manager()
        sessions = smgr.get_user_sessions(self.user)
        for s in sessions:
            smgr.delete_session(s.id)
        
        # remove from who's online
        get_user_database().hit_db.clear_hits(self.user)

        return request.redirect('./')


class UserThreadsUI(QonBaseUI):

    _q_exports = ['atom_xml']
    
    def __init__(self, request, user):
        self.user = user
        self.other_header = '''<link rel="service.feed" type="application/atom+xml" href="%s" title="%s" />''' % (
            blocks.util.full_url(blocks.user.path_to_user(self.user)) + 'threads/atom.xml',
            "%s's Recent Discussions" % blocks.util.display_name_plain(self.user))
        blocks.util.set_section_mode(request, 'Discussions')        
        blocks.util.set_menus(request,[])
        
    def _q_lookup(self, request, name):
        if 'atom_xml' in self._q_exports:
            if name.lower() in ['atom.xml']:
                return self.atom_xml(request)
        
        raise TraversalError
    
    def _get_items(self):
        # gather recent user contributions from user profile
        cur_user = get_user()
        threads = self.user.get_activity().recent_participation_for_reader(cur_user)
        items = [item for date, item in threads]
        return items
        
    def _q_index [html] (self, request):
        title = "ned.com: %s's Recent Discussions" % blocks.util.display_name_plain(self.user)
        blocks.util.header(request, title, other_header=self.other_header)
        
        '''
        <h1>%s's Recent Discussions</h1>
        <p class="formHelp">
        Displays the fifty (50) most recent discussions participated in across all groups and personal news.
        </p>
        ''' % blocks.util.display_name_plain(self.user)
        
        items = self._get_items()
        blocks.blog.display_items_table(items,
            count=50,
            title="Discussion",
            )
        blocks.util.footer()
    
    def atom_xml(self, request):
        request.response.set_header('content-type', 'text/xml; charset=utf-8')
        items = self._get_items()
        
        feed = atom.Feed()
        feed.title = "%s's Recent Discussions" % blocks.user.display_name_plain(self.user)
        feed.url = blocks.util.full_url(blocks.user.path_to_user(self.user) + 'threads/')
        feed.id = blocks.util.atom_id(self.user) + 'threads/'

        if items:
            feed.set_modified(items[0].watchable_last_change())
            for item in items:
                entry = blocks.blog.format_atom_item(item)
                feed.entries.append(entry)
        
        return feed.output()
        
    def get_crumb(self):
        return "Discussions"      

    
class UserPrivateUI(QonBaseUI):

    _q_exports = ['prefs', 'chpass', 'emails',  'confirm']
    
    def __init__(self, request, user):
        self.user = user
        blocks.util.set_help_block(request, 'User Settings')
        blocks.util.set_menu_mode(request, 'private/')
        blocks.util.set_section_mode(request, 'Settings')        
        blocks.util.prefix_menu_paths(request, '../')

        menus = [
            {
                'name': 'Edit profile',
                'path': 'prefs',
                'title': 'Change my name as it\'s displayed and my about me text',
            },
            {
                'name': 'Change password',
                'path': 'chpass',
                'title': 'Change the password I use to sign in',
            },
            {
                'name': 'Email addresses',
                'path': 'emails',
                'title': 'Add and remove email addresses associated with my account',
            },
            ]

        blocks.util.set_menus(request,menus)
            
    def _q_access(self, request):

        cur_user = get_user()

        if self.user is None:
            raise TraversalError
        if cur_user is not self.user:
            # allow staff to access
            if not cur_user or not cur_user.is_staff():
                raise AccessError
            
    def _staff_alert [html] (self):
        cur_user = get_user()
        if cur_user is not self.user:
            '''<p><span class="alert">Confidential Staff Information Only!</span>
            You are seeing this page because you are a staff member. Do not share
            or disclose to members.
                </p>
            '''

    def _no_staff_access(self):
        # don't allow staff access to the caller of this method
        cur_user = get_user()
        if cur_user is not self.user:
            raise AccessError

    def _q_index [html] (self, request):
        # handles /user/{username}/private/
        
        
        title = "User Settings"
        blocks.util.header(request, title)
        '<h2>%s</h2>' % title

        self._staff_alert()
        
        options = [
            ('prefs', 'Edit my profile'),
            ('chpass', 'Change password'),
            ('emails', 'Email addresses'),
            ]
            
        msg = request.get_form_var('msg')
        if msg:
            '''<p class="info">%s</p>''' % msg
        
        blocks.util.navigation(options, 'Select one:')
        
        blocks.util.footer(title)
        
    def get_crumb(self):
        return 'Settings'

    def prefs [html] (self, request):
        self._no_staff_access()

        blocks.util.set_menu_mode(request, 'prefs')
        title = "Edit profile"

        manage_form(request, UserPrefsForm,
            page_title=title,
            preview_text=_h(messages.preview_text),
            commit_title=title + ": changes saved.",
            commit_text='<p class="info">Your changes have been recorded.</p>',
            user=self.user)
        
    def chpass [html] (self, request):
        self._no_staff_access()

        # redirect to https if we got here via http
        if local.HTTPS_LOGIN and (request.scheme != 'https'):
            return request.redirect(blocks.util.full_url(blocks.user.path_to_user(self.user) + 'private/chpass', 'https'))

        blocks.util.set_menu_mode(request, 'chpass')

        title = "Change password"
        
        footer_text = ''
        if blocks.util.is_internal_user(self.user):
            # internal users have expiring passwords
            self.user.set_expiring_password(True)

            footer_text = '''<p><span class="alert">NOTE:</span> Because your account has
            additional security measures in place, successfully changing your password will
            sign you out immediately. You will receive an error telling you to sign in again.
            When you see the error, <span class="alert">click the home tab</span> and then
            sign in normally.
            </p>
            '''
                    
        manage_form(request, UserChangePasswordForm,
            page_title=title,
            heading_text='<p>Use this form to change your password to something easier to remember. '
            "If you've forgotten your password, use "
            '<a href="/user/newpass">this form</a> to request that a new one be sent to you.'
            '</p>',
            footer_text=footer_text,
            commit_title=title+": new password recorded",
            commit_text='<p class="info">Your new password has been recorded.</p>',
            user=self.user)
            
    def emails [html] (self, request):
        blocks.util.set_menu_mode(request, 'emails')
        title = "Email addresses"
        path = str(blocks.user.path_to_user(self.user) + 'private/emails')

        email_list = blocks.user.display_email_list(self.user)
        
        blocks.util.header(request, title)
        
        '<h2>%s</h2>' % title
        self._staff_alert()
        '<p>The following emails are associated with your account:</p>'
        email_list
        
        if self.user.unconfirmed_email_list():
            '<p><span class="alert">Note: </span>'
            'You have unconfirmed email addresses. '
            'Check your email at those accounts for a message containing a '
            'confirmation code. If you haven\'t received the email '
            'message within a few hours, add the same email address again and you\'ll be sent '
            'a new confirmation message. Be sure to check the accuracy of the email address '
            'you entered. You cannot use your new email address until it has been confirmed.'
            '</p>'
        
        '<br />'
        manage_form_in_page(UserEmailsForm,
            user=self.user,
            redirect_url=path,
            )
            
        '<hr noshade width="50%" />'
        manage_form_in_page(AddEmailForm,
            user=self.user,
            redirect_url=path,
            )
            
        '<hr noshade width="50%" />'
        manage_form_in_page(UserDeleteEmailForm,
            user=self.user,
            redirect_url=path,
            )
            
        blocks.util.footer()
                
    def confirm [html] (self, request):
        self._no_staff_access()
        blocks.util.set_menu_mode(request, '../private/confirm')
        title = "Confirm email address"

        manage_form(request, ConfirmEmailForm,
            page_title=title,
            commit_title=title + ": changes saved.",
            commit_text='<p class="info">Your email address has been confirmed.</p>',
            user=self.user)

class UserPrefsForm(QonForm):
    """Form controller for user prefs"""

    submit_button = 'submit-userprefs'
    preview_button = 'preview-userprefs'
    submit_buttons = [preview_button, submit_button]
    
    def __init__(self, user):
        QonForm.__init__(self)
        self.user = user
        self._build_form()
        
    def _build_form(self):
        pers_news_val = 'no'
        email_notify_val = 'no'
        copy_self_val = 'no'
        
        if self.user.get_user_data().anon_can_read_blog():
            pers_news_val = 'yes'
            
        if self.user.email_notify():
            email_notify_val = 'yes'

        if self.user.copy_self():
            copy_self_val = 'yes'
        
        self.add(StringWidget, 'name', title="Full name",
            value=self.user.contact_name,
            hint="Will be displayed on this site instead of your email address.",
            required=True)
            
        self.add(TextWidget, 'bio', title="About me",
            value=self.user.bio,
            rows=10, cols=60,
            hint="Please tell us a little about yourself.")

        self.add(StringWidget, 'location', title="Location",
            value=self.user.location,
            hint="Please tell us where you're from.")

        self.add(StringWidget, 'latitude', title="Latitude",
            value=self.user.latitude or '')

        self.add(StringWidget, 'longitude', title="Longitude",
            value=self.user.longitude or '',
            hint=_h('(Optional) By providing a latitude/longitude (in degrees or decimal values), you will be able to find other members close to you. Be sure to include the minus sign if in the western or southern hemisphere. %s' % href('http://www.geonames.org/postalcode-search.html', 'Look up your lat/long.', target='_blank')))    

        self.add(StringWidget, 'deliciousID', title="del.icio.us username",
            value=self.user.deliciousID or '',
            hint="enter username only - not full URL")

        self.add(StringWidget, 'flickrID', title="flickr alias",
            value=self.user.flickrID or '',
            hint="enter alias only - not full URL")
        
        self.add(StringWidget, 'skypeID', title="Skype Name",
            value=self.user.skypeID or '')

        self.add(StringWidget, 'blogURL', title="External blog URL", size=70,
            value=self.user.blogURL or '')           
            
        self.add_radiobuttons('pers-news',
            title='Allow users who are not signed in to read my personal news',
            hint='''If set, your personal news will be accessible by anyone on the Internet,
                including search engines.''',
            options=['no', 'yes'],
            value=pers_news_val,
            )
            
        self.add_radiobuttons('email-notify',
            title='Send me email when I receive a message via the internal message system.',
            hint='''If set, you will receive an email at your primary email address whenever
                you receive a message on ned.com's internal message system.''',
            options=['no', 'yes'],
            value=email_notify_val,
            ) 

        self.add_radiobuttons('copy-self',
            title='Copy me by email when I send a message via the internal message system.',
            hint='''If set, you will receive an email at your primary email address whenever
                you send a message on ned.com's internal message system.''',
            options=['no', 'yes'],
            value=copy_self_val,
            )
           
        self.add_submit(self.preview_button, 'Preview')
        self.add_submit(self.submit_button, 'Save')

    def validate(self):
        if not QonForm.validate(self):
            return False

        # is the bio too long?
        raw = self['bio']
        if raw:
            num_lines = raw.count('\n')
            # try to keep people from creating mosterous entries
            if num_lines > 2000:
                self.set_error('bio', 'Sorry, your bio contains %i lines. Please relocate some of the content to keep its length under 2000 lines, and try again.' % num_lines)

        # did they enter too much information for external sites?
        import re

        # for delicious, we want just the username
        # any slashes are a clear give-away that they have a URL in there
        deliciousID = self['deliciousID']
        if deliciousID:
            # since del.icio.us usernames can only use the characters a-z, 0-9, underscore, and period
            delicious_re = re.compile('[a-z|A-Z|0-9|_|\.]+$')
            if not delicious_re.match(deliciousID):
                # prompt them to give us just a username
                error = "Please provide only your delicious username."
                error += ' - for example use "janedoe" not "http://del.icio.us/tags/janedoe"'
    
                # guess that it's the end of the URL, and suggest that value.
                try:
                    username = re.match('.*/(\w+)', deliciousID).group(1)
                    self.get_widget('deliciousID').set_value(username)
                    error += " Please verify the username that has been entered."
                except:
                    pass

                self.set_error('deliciousID', error)

        flickrID = self['flickrID']
        if flickrID:
            flickr_re = re.compile('[a-z|A-Z|0-9|_|\.]+$')
            # ID may consist of a-z, 0-9, underscores, and a single dot (.)
            if not flickr_re.match(flickrID):
                # prompt them to give us just a username
                error = "Please provide only your flickr username."
                error += ' - for example use "janedoe" not "http://www.flickr.com/photos/janedoe"'
                self.set_error('flickrID', error)

        skypeID = self['skypeID']
        if skypeID:
            # from 6 to 32 characters
            # starts with a letter, no spaces, no dashes
            skype_re = re.compile('[a-z|A-Z][a-z|A-Z|0-9|_|\.]{5,31}$')
            if not skype_re.match(skypeID):
                # prompt them to give us just a username
                self.set_error('skypeID', "Please provide only your skype username. (6-32 characters, starting with a letter.)")

        return not self.has_errors()

    def preview [html] (self):
        '<p><span class="title">Full name: </span>%s<br />' % self['name']
        '<span class="title">About me:</span><br />%s<br />' % rst_to_html(self['bio'])
        '</p><hr noshade="noshade" />'
        self.render()

    def commit(self):
        name = self['name']
        bio = self['bio']
        location = self['location']        
        if name:
            name = name.strip()
        if bio:
            bio = bio.strip()
        if location:
            location = location.strip()            

        api.user_set_settings(self.user,
            name=name,
            bio=bio,
            location=location,
            latitude=standardize_lon_lat_coord(self['latitude']),
            longitude=standardize_lon_lat_coord(self['longitude']),
            deliciousID=self['deliciousID'],
            flickrID=self['flickrID'],
            skypeID=self['skypeID'],
            blogURL=standardize_url(self['blogURL']),                                
            anon_blog=self['pers-news'],
            email_notify=self['email-notify'],
            copy_self=self['copy-self'],
            )
        return get_request().redirect('../')


class UserChangePasswordForm(QonForm):
    """Form controller to change user password"""

    submit_button = 'submit-changepass'    
    submit_buttons = [submit_button]

    def __init__(self, user):
        QonForm.__init__(self)
        self.user = user
        self._build_form()
        
    def _build_form(self):
        self.add(PasswordWidget, 'oldpass', title="Old password",
            required=True)
        self.add(PasswordWidget, 'newpass1', title="New password",
            required=True)
        self.add(PasswordWidget, 'newpass2', title="New password again",
            hint="Enter your new password again for verification",
            required=True)
        self.add_submit(self.submit_button, 'Save')

    def validate(self):
        if not QonForm.validate(self):
            return False

        if not self.user.valid_password(self['oldpass']):
            self.set_error('oldpass', "Your password is incorrect.")
            return False
            
        if self['newpass1'] != self['newpass2']:
            self.set_error('newpass2', "You did not enter the same password both times.")
            return False
        
        # enforce strong password for internal users
        if blocks.util.is_internal_user(self.user):
            if not self.user.check_strong_password(self['newpass1']):
                self.set_error('newpass1', '''You must enter at least a 6-character password that
                contains at least one symbol and at least one digit. You must not use a password you
                have used recently.''')
                return False
            
        return True

    def commit(self):
        api.user_set_password(self.user, self['newpass1'])
        
        # redirect non-internal users back to http
        if not blocks.util.is_internal_user(self.user):
            path = blocks.util.full_url(blocks.user.path_to_user(self.user), 'http') + 'private/?msg='
            path += urllib.quote('Your new password has been recorded.')
            return get_request().redirect(path)
        else:
            # internal users need a little extra help, and redirect to /home/
            # FIXME this code fails because changing the user's password logs him out,
            # and he doesn't have permission to even access this page in order to get the
            # redirect. Seems like the redirect should just "work," but the AccessError is
            # taking precedence.
            path = blocks.util.full_url('/home/') + '?msg='
            path += urllib.quote('Your new password has been recorded and you have been signed out. Please sign in again now.')
            return get_request().redirect(path)

class NewUserForm(QonForm):
    """Form controller to create new user"""

    submit_button = 'submit-newuser'
    submit_buttons = [submit_button]

    def __init__(self, request):
        QonForm.__init__(self)
        self.request = request
        self._build_form()
        
    def _build_form(self):
        self.add(StringWidget, 'email', title='Email address')
        self.add(StringWidget, 'email2', title='Again for verification')
        self.add_submit(self.submit_button, 'Sign up!')
    
    def validate(self):
        if not QonForm.validate(self):
            return False
            
        # FIXME no validation that email is in valid email address format
        
        email = self['email']
        email2 = self['email2']
        if not email:
            self.set_error('email', "You must enter an email address.")
            return False
            
        if email and email != email2:
            self.set_error('email2', "You did not enter the same email address.")
            return False
            
        if not HasEmail.is_valid_email(email):
            self.set_error('email', "You did not enter a valid email address.")
            return False
        
        try:
            user_unused = get_user_database().get_user_by_email(email)
        except KeyError:
            pass    # user does not exist
        else:
            self.set_error('email', "That email address is already registered.")
            
        return not self.has_errors()

    def commit(self):
        if self.get_submit() == self.submit_button:
            result = api.user_new(self['email'])
        return result

class NewPasswordForm(QonForm):
    
    submit_button = 'submit-newpass'
    submit_buttons = [submit_button]
    
    def __init__(self, request):
        QonForm.__init__(self)
        self.request = request
        self.user = None
        self._build_form()
        
    def _build_form(self):
        self.add(StringWidget, 'email', title='Email address', required=True)
        self.add_submit(self.submit_button, 'Send password')
        
    def validate(self):
        if not QonForm.validate(self):
            return False
            
        self._lookup_user()
        if self.user is None:
            self.set_error('email', "That email does not exist.")
            
        return not self.has_errors()
        
    def commit(self):
        if self.get_submit() == self.submit_button:
            if self.user is not None:
                result = api.user_new_password(self.user, self['email'])
                return result
        return None
        
    def _lookup_user(self):
        try:
            self.user = get_user_database().get_user_by_email(self['email'])
        except KeyError:
            self.user = None
            

class AddEmailForm(QonForm):
    submit_button = 'submit-addemail'
    submit_buttons = [submit_button]
    
    def __init__(self, user, redirect_url):
        QonForm.__init__(self)
        self.user = user
        self.redirect_url = redirect_url
        self._build_form()
        
    def _build_form(self):
        self.add_string('email', title="Add an email address", required=True)
        self.add_submit(self.submit_button, 'Add')
        
    def validate(self):
        if not QonForm.validate(self):
            return False

        if not HasEmail.is_valid_email(self['email']):
            self.set_error('email', "You did not enter a valid email address.")
            return False
        
        try:
            user = get_user_database().get_user_by_email(self['email'])
        except KeyError:
            pass
        else:
            if user != self.user:
                self.set_error('email', 'That email address is already registered by another user.')
            else:
                self.set_error('email', 'That email address is already associated with your account.')
            return False
        return True

    def commit(self):
        if self.get_submit() == self.submit_button:
            result_unused = api.user_add_email(self.user, self['email'])
        return get_request().redirect(self.redirect_url)        
        
class ConfirmEmailForm(QonForm):
    submit_button = 'submit-confirmemail'
    submit_buttons = [submit_button]
    
    def __init__(self, user):
        QonForm.__init__(self)
        self.user = user
        self._build_form()
        
    def _build_form(self):
        self.add_string('code', title="Please type your confirmation code", required=True,
            hint="This is the code you received at your new email address.")
        self.add_submit(self.submit_button, 'Confirm')
        
    def validate(self):
        if not QonForm.validate(self):
            return False
            
        if not api.user_confirm_email(self.user, self['code']):
            self.set_error('code', 'Invalid confirmation code.')
            return False
        return True

    def commit(self):
        if self.get_submit() == self.submit_button:
            # we did the work in validate
            return True
        return None

class UserEmailsForm(QonForm):
    submit_button = 'submit-primaryemail'
    submit_buttons = [submit_button]
    
    def __init__(self, user, redirect_url):
        QonForm.__init__(self)
        self.user = user
        self.redirect_url = redirect_url
        self._build_form()
        
    def _build_form(self):
        options = self.user.email_list()
        value = self.user.get_primary_email()
        
        self.add_single_select(self.mangle('email'), title='Change your primary email address',
            options=options,
            value=value,
            )
        self.add_submit(self.submit_button, 'Select')

    def validate(self):
        if not QonForm.validate(self):
            return False
            
        if self[self.mangle('email')] not in self.user.email_list():
            self.set_error(self.mangle('email'), 'Invalid email address')
            return False
            
        return True
        
    def commit(self):
        if self.get_submit() == self.submit_button:
            if self[self.mangle('email')] != self.user.get_primary_email():
                api.user_set_primary_email(self.user, self[self.mangle('email')])
        return get_request().redirect(self.redirect_url)
        
class UserDeleteEmailForm(QonForm):
    submit_button = 'submit-deleteemail'
    submit_buttons = [submit_button]
    
    def __init__(self, user, redirect_url):
        QonForm.__init__(self)
        self.user = user
        self.redirect_url = redirect_url
        self._build_form()
        
    def _build_form(self):
        options = self.user.email_list() + self.user.unconfirmed_email_list()
        
        self.add_single_select(self.mangle('email'), title='Delete an email address',
            options=options,
            )
        self.add_submit(self.submit_button, 'Delete')

    def validate(self):
        if not QonForm.validate(self):
            return False
            
        if self[self.mangle('email')] not in (self.user.email_list() + self.user.unconfirmed_email_list()):
            self.set_error(self.mangle('email'), 'Invalid email address')
            return False
        
        if self[self.mangle('email')] == self.user.get_primary_email():
            self.set_error(self.mangle('email'), 'You cannot delete your primary email address.')
            return False
        
        if len(self.user.email_list()) + len(self.user.unconfirmed_email_list()) == 1:
            self.set_error(self.mangle('email'), 'You cannot delete your last email address.')
            return False
            
        return True
        
    def commit(self):
        if self.get_submit() == self.submit_button:
            if self[self.mangle('email')] != self.user.get_primary_email():
                api.user_delete_email(self.user, self[self.mangle('email')])
        return get_request().redirect(self.redirect_url)

# ------------------------------------------------------------------------------------------

class ActiveUI(QonBaseUI):
    _q_exports = []

    def __init__(self, request, name=None):
        self.name = name    # active = summary page, recent = most active recently, new = newly registered users
        
        # set sub-tab
        blocks.util.set_section_mode(request, 'Active')

        # gather the info
        db = get_list_database()
        
        most_active_users_list = db.most_active()
        most_active_users = [blocks.user.display_name(u[0]) for u in most_active_users_list]
        most_active_activity = [u[1] for u in most_active_users_list]
        self.most_active_users_zipped = qon.util.zip_lists(range(1,len(most_active_users_list)+1), most_active_users, most_active_activity)
        
        newest_users = db.newest_users()
        newest_users_names = [blocks.user.display_name(u) for u in newest_users]
        newest_users_dates = [format_ago(u.member_since()) for u in newest_users]
        self.newest_users_zipped = qon.util.zip_lists(range(1,len(newest_users)+1), newest_users_names, newest_users_dates)        
        
    def _q_index [html] (self, request):

        # check to see that if we're showing just the summary page        
        if self.name == 'active':
            if len(self.most_active_users_zipped) > _num_to_show_in_summary*3:
                self.most_active_users_zipped = self.most_active_users_zipped[:_num_to_show_in_summary*3]
                self.most_active_users_zipped.extend(('', href('recent/', 'see full list...'), ''))  
            if len(self.newest_users_zipped) > _num_to_show_in_summary*3:
                self.newest_users_zipped = self.newest_users_zipped[:_num_to_show_in_summary*3]
                self.newest_users_zipped.extend(('', href('new/', 'see full list...'), ''))                 
        
        title = "ned.com: Most Active Users"

        blocks.util.header(request, title)
        
        '<h1>'
        if self.name == 'active':
            'Most Active Users'
        if self.name == 'recent':
            'Most Active Users Recently'
        if self.name == 'new':
            'Newest Members'            
        '</h1>'

        '''
        <table width="100%">
        <tr>
        '''
        if self.name == 'active' or self.name == 'recent':
            '''
            <td valign="top">
            <p class="formHelp">
            Ranked by activity in the last 3 days.
            </p>           
            '''+blocks.util.format_table(3,
                self.most_active_users_zipped,
                headings=['', 'Most Active Recently', 'Posts',],
                table_class="user-listing",
                centered_columns=[])+'''
            </td>
            '''
        if self.name == 'active' or self.name == 'new':
            '''
            <td valign="top">
            <p class="formHelp">
            Most recently signed-up users.
            </p>           
            '''+blocks.util.format_table(3,
                self.newest_users_zipped,
                headings=['', 'Newest Members', 'Joined'],
                table_class="user-listing",
                centered_columns=[])+'''
            </td>
            '''
        '''    
        </tr>
        </table>
        '''
        
        '''
        <p class="formHelp">
        Rankings are updated hourly.
        </p>
        '''
        
        blocks.util.footer()

    def get_crumb(self):
        if self.name == 'recent':
            return 'Recently'
        if self.name == 'new':
            return 'Newest Users'
        return 'Most Active Users'

    def _q_lookup (self, request, name):
        if name == 'recent' or name == 'new':
            return ActiveUI(request, name)

# ------------------------------------------------------------------------------------------

class TaggedUI(QonBaseUI):
    _q_exports = []

    def __init__(self, request, name=None):
        self.name = name    # active = summary page, recent = most active recently, new = newly registered users
        
        # set sub-tab
        blocks.util.set_section_mode(request, 'Tagged')

    def _q_index [html] (self, request):

        # Show a tag cloud of tags applied to users
        user_db = get_user_database()

        title = "ned.com: Tags Applied to Members"
        blocks.util.header(request, title)
        
        '<h1>'
        'Tags Applied to Members'
        '</h1>'

        tags_n_counts = user_db.get_tags_n_counts()
        if tags_n_counts:
            '<br />'
            qon.ui.blocks.tags.cloud(tags_n_counts, None, "./", mini_cloud=False)
            #
        # 
        else:
            '<br />'
            'No tags have been applied to members yet.'
            '<br />'
        #
        
        blocks.util.footer()

    def get_crumb(self):
        return "Tagged"

    def _q_lookup(self, request, component):
        return self.tag_results(request, component)

    def tag_results [html] (self, request, component):
        tags = component.split(str(','))
        tags_str = ', '.join(tags)
        title = "ned.com: Tagged Members Results"
        blocks.util.header(request, title)

        '<H1>'
        'Members tagged with %s' % (component)
        '</H1>'
        '<br />'
        user_db = get_user_database()
        item_oids = user_db.get_tagged_items(tags)
        if item_oids:
            '<TABLE><TR><TD WIDTH="90%">'
            qon.ui.blocks.tags.tagged_items_table(item_oids, tags)
            '</TD>'
            '<TD>'

            # find related tags
            tags_n_counts = user_db.get_related_tags_n_counts(tags)
            related_tags = [tag for tag, count in tags_n_counts]
            related_link = "../tagged/%s," % ",".join(tags)
            if tags_n_counts and len(item_oids) > 1:
                'Narrow&nbsp;your&nbsp;results: '
                qon.ui.blocks.tags.cloud(tags_n_counts, user_db, related_link, mini_cloud=True)
            #
            '</TD></TR></TABLE>'

            if len(tags) > 1:
                all_tags = tags + related_tags
            else:
                # the one current tag would just link back to this page
                all_tags = related_tags

            if len(all_tags) > 1:
                links = ['<A HREF="../tagged/%s">%s</A>' % (tag,tag) for tag in all_tags]
                'See everybody tagged with: %s <br />' %  ", ".join(links)
            #
        else:
            "Nobody has been tagged with %s yet" % tags_str

        blocks.util.footer()
    #

    def old_tag_results [html] (self, request, component):
        title = "ned.com: Tagged Members Results"
        blocks.util.header(request, title)

        '<H1>'
        'Members tagged with %s' % (component)
        '</H1>'
        '<br />'
        user_db = get_user_database()
        item_oids = user_db.get_tagged_items(component)
        if item_oids:
            '<TABLE><TR><TD WIDTH="90%">'
            qon.ui.blocks.tags.tagged_items_table(item_oids, tags)
            '</TD>'
            '<TD>'

            # find related tags
            tags_n_counts = user_db.get_related_tags_n_counts(tags)
            related_tags = [tag for tag, count in tags_n_counts]
            related_link = "../tags/%s," % ",".join(tags)
            if tags_n_counts and len(item_oids) > 1:
                'Narrow&nbsp;your&nbsp;results: '
                qon.ui.blocks.tags.cloud(tags_n_counts,tags_db, related_link, mini_cloud=True)
            #
            '</TD></TR></TABLE>'

            if len(tags) > 1:
                all_tags = tags + related_tags
            else:
                # the one current tag would just link back to this page
                all_tags = related_tags

            if len(all_tags) > 1:
                links = ['<A HREF="../tags/%s">%s</A>' % (tag,tag) for tag in all_tags]
                'See everybody tagged with: %s <br />' %  ", ".join(links)
            #
        else:
            "Nobody has been tagged with %s yet" % tags_str

        blocks.util.footer()
    #

# ------------------------------------------------------------------------------------------

class LargestBanksUI(QonBaseUI):
    _q_exports = []
    
    def __init__(self, request, name):       
        # set sub-tab
        blocks.util.set_section_mode(request, 'Largest Banks')
        
    def _q_index [html] (self, request):        
        db = get_list_database()
        
        title = "ned.com: Largest Banks"
        
        blocks.util.header(request, title)
        
        '<h1>'
        'Largest Banks'
        '</h1>'
        
        big_bank = sort_list(db.biggest_bank(), lambda x: x.get_karma_bank_balance()) # sort in case cached list is not in sync with real-time values
        big_bank_names = [blocks.user.display_name(u, nonex='&nbsp;') for u in big_bank]
        big_bank_values = [u.get_karma_bank_balance() for u in big_bank]
        big_bank_zipped = qon.util.zip_lists(range(1,len(big_bank)+1), big_bank_names, big_bank_values)
        
        '''
        <table width="100%">
        <tr>
            <td valign="top">
            <p class="formHelp">
            Ranked by current points in bank.
            </p>           
            '''+blocks.util.format_table(3,
                big_bank_zipped,
                headings=['', 'Largest Feedback Bank', 'Bank'],
                table_class="user-listing",
                centered_columns=[])+'''
                </td>
            <td valign="top">
            </td>
        </tr>
        </table>
        '''

        '''
        <p class="formHelp">
        Rankings are updated hourly.
        </p>
        '''
        
        blocks.util.footer() 
        
    def get_crumb(self):
        return "Largest Banks"

# ------------------------------------------------------------------------------------------

class TopRatedUI(QonBaseUI):
    _q_exports = []
    
    def __init__(self, request, name=None):
        self.name = name    # top = summary page, feedback = top rated users, commentors = top commentors, friends = most friends
        
        # set sub-tab
        blocks.util.set_section_mode(request, 'Top Rated')

        # gather the info
        db = get_list_database()
        
        top_users = sort_list(db.top_users(), lambda x: x.get_karma_score()) # sort in case cached list is not in sync with real-time values
        top_users_names = [blocks.user.display_name(u) for u in top_users]
        top_users_fb = [u.get_karma_score() for u in top_users]
        self.top_users_zipped = qon.util.zip_lists(range(1,len(top_users)+1), top_users_names, top_users_fb)

        top_contrib = db.karma_top_user_content()
        top_contrib_names = [blocks.user.display_name(u) for tot, u, pos, neg in top_contrib]
        top_contrib_score = [tot for tot, u, pos, neg in top_contrib]
        self.top_contrib_zipped = qon.util.zip_lists(range(1,len(top_contrib)+1), top_contrib_names, top_contrib_score)
        
        most_friends = sort_list(db.most_friends(), lambda x: len(x.positive_karma_givers())) # sort in case cached list is not in sync with real-time values
        most_friends_names = [blocks.user.display_name(u) for u in most_friends]
        most_friends_counts = [len(u.positive_karma_givers()) for u in most_friends]
        self.most_friends_zipped = qon.util.zip_lists(range(1,len(most_friends)+1), most_friends_names, most_friends_counts)
        
    def _q_index [html] (self, request):
        
        # check to see that if we're showing just the summary page        
        if self.name == 'top':
            if len(self.top_users_zipped) > _num_to_show_in_summary*3:
                self.top_users_zipped = self.top_users_zipped[:_num_to_show_in_summary*3]
                self.top_users_zipped.extend(('', href('feedback/', 'see full list...'), ''))  
            if len(self.top_contrib_zipped) > _num_to_show_in_summary*3:
                self.top_contrib_zipped = self.top_contrib_zipped[:_num_to_show_in_summary*3]
                self.top_contrib_zipped.extend(('', href('commenters/', 'see full list...'), ''))
            if len(self.most_friends_zipped) > _num_to_show_in_summary*3:
                self.most_friends_zipped = self.most_friends_zipped[:_num_to_show_in_summary*3]
                self.most_friends_zipped.extend(('', href('friends/', 'see full list...'), ''))                
        
        title = "ned.com: Top-Rated Users"
        
        blocks.util.header(request, title)
        
        '<h1>'
        if self.name == 'top':
            'Top-Rated Users'
        if self.name == 'feedback':
            'Top-Rated Users by Feedback Score'
        if self.name == 'commenters':
            'Top Commenters'
        if self.name == 'friends':
            'Most Friends'           
        '</h1>'

        
        '''
        <table width="100%">
        <tr>
        '''
        if self.name == 'top' or self.name == 'feedback':
            '''        
            <td valign="top">
            <p class="formHelp">
            Ranked by overall feedback ratings.
            </p>        
            '''+blocks.util.format_table(3,
                self.top_users_zipped,
                headings=['', 'Top Rated Users', 'Feedback'],
                table_class="user-listing",
                centered_columns=[])+'''
            </td>
            '''
        if self.name == 'top' or self.name == 'commenters':
            '''              
            <td valign="top">
            <p class="formHelp">
            Ranked by total feedback received on comments made.
            </p>                
            '''+blocks.util.format_table(3,
                self.top_contrib_zipped,
                headings=['', 'Top Commenters', 'Feedback'],
                table_class="user-listing",
                centered_columns=[])+'''
            </td>
            '''
        '''    
        </tr>
        <tr>
        '''
        if self.name == 'top' or self.name == 'friends':
            '''          
            <td valign="top">
            <p class="formHelp">
            Ranked by the number of unique users giving positive feedback.
            </p>                
            '''+blocks.util.format_table(3,
                self.most_friends_zipped,
                headings=['', 'Most Friends', 'Friends'],
                table_class="user-listing",
                centered_columns=[])+'''
            </td>
            '''
            '''
            <td></td>
            '''
        '''    
        </tr>
        </table>
        '''

        '''
        <p class="formHelp">
        Rankings are updated hourly, except Top Commenters, which are updated daily.
        </p>
        '''
        
        blocks.util.footer()
        
    def get_crumb(self):
        if self.name == 'feedback':
            return 'By Feedback Score'
        if self.name == 'commenters':
            return 'Top Commenters'
        if self.name == 'friends':
            return 'Most Friends'
        return 'Top-Rated'

    def _q_lookup (self, request, name):
        if name == 'feedback' or name == 'commenters' or name == 'friends':
            return TopRatedUI(request, name)    

# ------------------------------------------------------------------------------------------

class LargestBanksUI(QonBaseUI):
    _q_exports = []
    
    def __init__(self, request, name=None):
        
        # set sub-tab
        blocks.util.set_section_mode(request, 'Largest Banks')
        
    def _q_index [html] (self, request):        
        db = get_list_database()
        
        title = "ned.com: Largest Banks"
        
        blocks.util.header(request, title)
        
        '<h1>'
        'Largest Banks'
        '</h1>'
        
        big_bank = sort_list(db.biggest_bank(), lambda x: x.get_karma_bank_balance()) # sort in case cached list is not in sync with real-time values
        big_bank_names = [blocks.user.display_name(u, nonex='&nbsp;') for u in big_bank]
        big_bank_values = [u.get_karma_bank_balance() for u in big_bank]
        big_bank_zipped = qon.util.zip_lists(range(1,len(big_bank)+1), big_bank_names, big_bank_values)
        
        '''
        <table width="100%">
        <tr>
            <td valign="top">
            <p class="formHelp">
            Ranked by current points in bank.
            </p>           
            '''+blocks.util.format_table(3,
                big_bank_zipped,
                headings=['', 'Largest Feedback Bank', 'Bank'],
                table_class="user-listing",
                centered_columns=[])+'''
                </td>
            <td valign="top">
            </td>
        </tr>
        </table>
        '''

        '''
        <p class="formHelp">
        Rankings are updated hourly.
        </p>
        '''
        
        blocks.util.footer() 
        
    def get_crumb(self):
        return "Largest Banks"

# ------------------------------------------------------------------------------------------

class FeedbackGivenAwayUI(QonBaseUI):
    _q_exports = []
    
    def __init__(self, request, name=None):
        self.name = name    # feedbackgiven = summary page, positive = most positive, negative = most negative
        
        # set sub-tab
        blocks.util.set_section_mode(request, 'Feedback Given Away')

        # gather info
        db = get_list_database()
        most_generous = sort_list(db.most_generous(), lambda x: x.karma_plus_given()) # sort in case cached list is not in sync with real-time values
        most_generous_names = [blocks.user.display_name(u) for u in most_generous]
        most_generous_values = [u.karma_plus_given() for u in most_generous]
        self.most_generous_zipped = qon.util.zip_lists(range(1,len(most_generous)+1), most_generous_names, most_generous_values)
        
        most_critical = sort_list(db.most_critical(), lambda x: x.karma_minus_given()) # sort in case cached list is not in sync with real-time values
        most_critical_names = [blocks.user.display_name(u) for u in most_critical]
        most_critical_values = [u.karma_minus_given() for u in most_critical]
        self.most_crtiical_zipped = qon.util.zip_lists(range(1,len(most_critical)+1), most_critical_names, most_critical_values)        
        
    def _q_index [html] (self, request):        

        # check to see that if we're showing just the summary page        
        if self.name == 'feedbackgiven':
            if len(self.most_generous_zipped) > _num_to_show_in_summary*3:
                self.most_generous_zipped = self.most_generous_zipped[:_num_to_show_in_summary*3]
                self.most_generous_zipped.extend(('', href('positive/', 'see full list...'), ''))  
            if len(self.most_crtiical_zipped) > _num_to_show_in_summary*3:
                self.most_crtiical_zipped = self.most_crtiical_zipped[:_num_to_show_in_summary*3]
                self.most_crtiical_zipped.extend(('', href('negative/', 'see full list...'), '')) 

        title = "ned.com: Most Feedback Given"
        
        blocks.util.header(request, title)
        
        '<h1>'
        if self.name == 'feedbackgiven':
            'Most Feedback Given Away'
        if self.name == 'positive':
            'Most Positive Feedback Given Away'
        if self.name == 'negative':
            'Most Negative Feedback Given Away'            
        '</h1>'
        
        '''
        <table width="100%">
        <tr>
        '''
        if self.name == 'feedbackgiven' or self.name == 'positive':
            '''
            <td valign="top">
            <p class="formHelp">
            Ranked by the number of positive feeback points given away.
            </p>           
            '''+blocks.util.format_table(3,
                self.most_generous_zipped,
                headings=['', 'Most Positive Feedback Given Away', '+'],
                table_class="user-listing",
                centered_columns=[])+'''
            </td>
            '''
        if self.name == 'feedbackgiven' or self.name == 'negative':
            '''            
            <td valign="top">
            <p class="formHelp">
            Ranked by the number of negative feeback points given away.
            </p>           
            '''+blocks.util.format_table(3,
                self.most_crtiical_zipped,
                headings=['', 'Most Negative Feedback Given Away', '-'],
                table_class="user-listing",
                centered_columns=[])+'''
            </td>
            '''
        '''    
        </tr>
        </table>
        '''

        '''
        <p class="formHelp">
        Rankings are updated hourly.
        </p>
        '''
        
        blocks.util.footer()  
        
    def get_crumb(self):
        if self.name == 'positive':
            return 'Positive'
        if self.name == 'negative':
            return 'Negative'
        return 'Most Feedback Given Away'        

    def _q_lookup (self, request, name):
        if name == 'positive' or name == 'negative':
            return FeedbackGivenAwayUI(request, name)
        
# ------------------------------------------------------------------------------------------

class NearMeUI(QonBaseUI):
    _q_exports = []
    
    def __init__(self, request, name=None):
        
        # set sub-tab
        blocks.util.set_section_mode(request, 'Near Me')
        
    def _q_index [html] (self, request):
        _num_per_page = 100
        
        user_db = get_user_database()
        
        title = "ned.com: People Near Me"
        
        blocks.util.header(request, title)
        
        user = get_user()
        if not user:
            raise AccessError

        latitude = standardize_lon_lat_coord(request.get_form_var('lat'))
        if latitude is None:
            latitude = user.latitude
        longitude = standardize_lon_lat_coord(request.get_form_var('long'))
        if longitude is None:
            longitude = user.longitude
        page = request.get_form_var('page')
        if page is None:
            page = 1
        page = int(page)
        


        if user and latitude is not None and longitude is not None:
            latitude = float(latitude)
            longitude = float(longitude)
            near_me = sort_list(user_db.get_user_distances(latitude, longitude), lambda x: -x[1]) # sort by distance
            num_total = len(near_me)
            total_num_pages = int((num_total-1) / _num_per_page) + 1
            if page < 0:
                page = 0
            if page > total_num_pages:
                page = total_num_pages
            near_me = near_me[(page-1)*_num_per_page:(page*_num_per_page)]
            near_me_names = [blocks.user.display_name(u[0], nonex='&nbsp;') for u in near_me]
            near_me_locations = [u[0].location for u in near_me]
            near_me_lat_lons = ['%.2f/%.2f' % (u[0].latitude, u[0].longitude) for u in near_me]
            near_me_values = ['%d' % int(u[1]) for u in near_me]
            end_range = page*_num_per_page+1
            if end_range > num_total+1:
                end_range = num_total+1
            near_me_zipped = qon.util.zip_lists(range((page-1)*_num_per_page+1, end_range), near_me_names, near_me_locations, near_me_lat_lons, near_me_values)

            # page navigation links
            if total_num_pages > 1:
                if request.get_form_var('lat') and request.get_form_var('long'):
                    url = ('<a href="/user/nearme/?lat=%.2f&long=%.2f' % (latitude, longitude)) + '&page=%s">'
                else:
                    url = '<a href="/user/nearme/?page=%s">'
                pagenav = blocks.util.get_pagenav(page, total_num_pages, url)
            else:
                pagenav = ''

            if (page > 1) or (total_num_pages > 1):
                '<h2>%sNear Me</h2>' % pagenav
            else:
                '<h2>Near Me</h2>'
                
            '''
            <table width="100%%">
            <tr>
                <td valign="top">
                <p class="formHelp">
                Members closest to %.2f/%.2f. Includes only the %d members who have added a lat/long to their user profiles.
                </p>           
                ''' % (latitude, longitude, num_total)
            
            blocks.util.format_table(5,
                    near_me_zipped,
                    headings=['', 'Nearest', 'Location', 'Lat/Long', 'Miles Away'],
                    table_class="user-listing",
                    centered_columns=[])
            '''
                    </td>
                <td valign="top">
                </td>
            </tr>
            </table>
            <hr />
            '''
            
            manage_form_in_page(NearLocationForm, heading_text='Or instead, find members near an alternate location:')
        else:
            '<h1>'
            'Near Me'
            '</h1>'            
            '''<br/ >To use this feature, you must first %s to your user profile.''' % href('/user/%s/private/prefs' % user.get_user_id(), 'add a lat/long')
        
        blocks.util.footer() 
        
    def get_crumb(self):
        return "Near Me"

class NearLocationForm(QonForm):
    submit_button = 'submit-nearlocation'
    submit_buttons = [submit_button]
    
    def __init__(self, latitude=None, longitude=None):
        QonForm.__init__(self)
        self.latitude = latitude
        self.longitude = longitude
        self._build_form()
                
    def _build_form(self):
        self.add(StringWidget, 'lat', title="Latitude",
            value=self.latitude or '')

        self.add(StringWidget, 'long', title="Longitude",
            value=self.longitude or '',
            hint=_h('%s' % href('http://www.geonames.org/postalcode-search.html', 'Look up a lat/long.', target='_blank')))
        
        self.add_submit(self.submit_button, 'Find')
        
    def validate(self):
        if not QonForm.validate(self):
            return False

        self.latitude=standardize_lon_lat_coord(self['lat'])
        self.longitude=standardize_lon_lat_coord(self['long'])

        if self.latitude is None:
            self.set_error('lat', 'Invalid latitude.')
            return False
        
        if self.longitude is None:
            self.set_error('long', 'Invalid longitude.')
            return False

        return True

    def commit(self):
        if self.get_submit() == self.submit_button:
            return get_request().redirect('/user/nearme/?lat=%.3f&long=%.3f' % (self.latitude, self.longitude))
            # return 'Showing members near the following location:' + self.render() # show form again
        return None
